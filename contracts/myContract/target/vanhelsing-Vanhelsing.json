{"noir_version":"0.32.0+92ff2fa2e944722e5c3fa43fb3363f093b8f1d12","name":"Vanhelsing","functions":[{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"feeTo","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"currentFee","type":{"kind":"field"},"visibility":"private"},{"name":"minCoffinPeriod","type":{"kind":"field"},"visibility":"private"},{"name":"maxCoffinPeriod","type":{"kind":"field"},"visibility":"private"},{"name":"minStakePeriod","type":{"kind":"field"},"visibility":"private"},{"name":"maxStakePeriod","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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LSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLSnKLelV3FJeXLbtbTnfviPFqp6Gk7Wzo5QP/+JJix9IyzWfAzml7aueejdrHz4U1sueDwl+uuz5g2OdnlYR7tmeTZ+U16u+is3+vvKyurSU9r6G7br/n/lJSfn+Z+5VbFZ/e0K3Z3S7oNsV3W7odke3F3R7RbejWS1oVgua1YJmtaBZLWhWC5rVgma1oFktaFYLmtWKZrWiWa1oViua1YpmtaJZrWhWK5rVima1olltaFYbmtWGZrWhWW1oVhua1YZmtaFZbWhWG5lVWxZ0e0K3Z3S7oNsV3W7odke3F3R7RbejWU1oVhOa1YRmNaFZTWhWE5rVhGY1oVlNaFYTmtWMZjWjWc1oVjOa1YxmNaNZzWhWM5rVjGY1o1kVNKuCZlXQrAqaVUGzKmhWBc2qoFkVNKuCZlXRrCqaVUWzqmhWFc2qollVNKuKZlXRrCqaVUOzamhWDc2qoVk1NKuGZtXQrBqaVUOzinJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLhnJLjnJLjnJLjnJLjnJLvii63dDtjm4v6PaKbkezinJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLjnJLvs8ttbTe7myaLv8XUm7pNJtEZRsuvjNsta7D1s6Ogu5fKLUiq3grXjrTtW4HR2uT59Mnr2Uir3Uir20er/u8W1CvaSKveSKvMpFXncirTeR1ot60T7Q2WyW1WuJ4rRN5bdN4LfvscVCvaSKveSKvMpFXncirTeTVJ/I6T28q++86tFZW/cuZ/uHNtonM7r8JEtVsmslsnsmszGRWZzJrM5n1mcyWmczO1KD2X4hLi8nm9uwP0xzd7f4LemHdpqnc5qncylRudSq3NpVbn8ptmcptncrtVF1q/wXq9OBxNZAsTk/ef6E7rNs8lVuZyq1O5damcutTuS1Tua1TuW0zudWpupT+oEv51pPzEuc35DVP5VamcqtTubWp3PpUbstUbutUbttMbm2Zyu1UXeqqA02W1q+JSd1G296oSvbTrIpYR7errT3dtdie7mteezddvypWvaM7y+pRs9WO7lLaqrtUSc91P/zov+9+//Dup4/vPz/8O9/+4R/3P3/58On+9MMv//vt8Z88zP4f"},{"name":"createCoffin","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"stakingToken","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"rewardsToken","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"periodInDays","type":{"kind":"field"},"visibility":"private"},{"name":"rewardsAmount","type":{"kind":"field"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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422F422F432F432F432F432F432F432F432F432F432F432F4+cKx88Vjp8rHD9XOH6ucPxc4fi5wvFzhePnCsfPFY6PFY5fwdz5CubOVzB3voK58xXMna9g7nwFc+crmDtfwdz5CubOVzB3voK58xXMna9g7nwFc+crmDtfwdz5CubOVzB3voK58xXMnT+DubOoWxDfxl6QsSKIrQjiK4LMFUFiRZBcEaT4QeYzmLvjILIiiK4IMlYEsRVBfEWQuSJIrAiSK4KscLyscLyscLyscLyscLyscLyscLyscLyscLyscLyscLyucLyucLyucLyucLyucLyucLyucLyucLyucLyucPxY4fixwvFjhePHCsePFY4fKxw/Vjh+rHD8WOH4scLxtsLxtsLxtsLxtsLxtsLxtsLxtsLxtsLxtsLxtsLxvsLxvsLxvsLxvsLxvsLxvsLxvsLxvsLxvsLxvsLxc4Xj5wrHzxWOnyscP1c4fq5w/Fzh+LnC8XOF4+cKx8cKx8cKx8cKx8cKx8cKx8cKx8cKx8cKx8cKx8cKx+cKx+cKx+cKx+cKx+cKx+cKx+cKx+cKx+cKx+cKx9cKx9cKx69g7uYK5m6uYO7mCuZurmDu5grmbq5g7uYK5i5WMHexgrmLFcxdrGDuYrMVQXxFkLkiSKwIkiuCrHD8CuYuVjB3sYK5ixXMXaxg7mIFcxcrmLtYwdzFCuYuVjB3sYK5ixXMXaxg7mIFcxcrmLtYwdzFCuYuVjB3sYK5ixXMXaxg7uIRczf1HuT976bcCyJa8rpYhr0F2f8dmZm3xV7j7beW7/+OTI9x/42aMeNgdWbdvsSXNb5cfTuuXuu441rHtWsd16913Hmt48a1jpvXOm5d6riPaOLf6nGvdauya92q7Fq3KrvWrcqudauya92q7Fq3KrvWrcqudavya92q/Fq3Kr/Wrcqvdavya92q/Fq3Kr/Wrcqvdavya92q/Fq3qnmtW9W81q1qXutWNa91q5rXulXNa92q5rVuVfNat6p5rVvVvNatKq51q4pr3ariWrequNatKq51q4pr3ariWrequNatKq51q4pr3aryWreqvNatKq91q8pr3aryWreqvNatKq91q8pr3aryWreqvNatqq51q6pr3arqWrequtatqq51q6pr3arqWrequtatqq51q6pL3apyu8qt6uVP//P9n3/4/t/++Ie/vOz5+X/+9cd//+mHP/34+sef/ve///F/Xtb+Hw=="},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+2de5QkeVXno6qzsrK7urLr1fWu7qzu4bGCmF1ZMw3Da2CFFUYPOB5Zj3AWepgeZnCYYWZ6GIa36AIuKiwIf6ijgIAoIEcRV0DmCKirDAu76AFEFx08LIIi8hJ8gEvk5O385K37i8yIjBsZ2VN5Tp3KjPhF/O69v9f3Pn73NxHd/Zn5zt9E5/tU53812vuRMpd1/jeH+5zK8V1NTzonxoTOyTGh88CY0FnJkc6YtgNR7ydveqcc5Jo3jdUxoHE653YXGiud77Xv/B38zt+h6O65d89NMjbZ6Tjx/biBYwFOo0zopb+ihBN//hHf1zr/H3HTTWdua1x7/VVnn9244ZZzjRuublx5wy3XX3UzH/wGvm90/j/1zHXXNc7d0Dhz881nbzr35GecefaTr7z23JNvvvY5Z/noxETGOmtZH/yLrA+uH8j44C4e3O78P3Pu3NlnPPNcLKGbb7ny3E1nnnquceu1565p3PCsszddfd0Nt/IFD8pa888NW/PtWWv+lawPfgQPbu4l+cxVV4Wp/euslf6/rA9WKtmpbVQyVnrvrA9+7xDUPiVrpT+W9cGbsj74yiHYfFfWSv96iEr/LWulO1MZH7wy64MvmsrOJrWGVJU+qpq90h/OWukTsz542xDUviZrpa/L+uCvZn3wD4dg8wtZKz06nb3SxnTGSu+d9cHvHYLam7JWelvWB685mPHBF+PBTCjjpVlr/sywNf9d1pq/nPXBzUP4vpfkxD7xgEMZK93N+uAVQ1B7fdZKz2V98FVDUPsbWSt9d9YHfz/rg58egs0DMxkrfcBM9kofnbXS52V98G1ZH/zQEGw+9nDGSl9xOHulv5y10jdlffCDQ1D7V1kr/ULWB7+c9cEjs9nZ3J3NWOmTh6j06VkrfWbWB392CGr/IGuld2Z98GNZH/zFesYH/+JIxge/jgcz4Zp/yVrzD88NWfN/mctY81VZH3wFHkzbC1+ftdJfzfrgHw5B7V1ZK/1c1gen5rNTuz2fsdL7Z32wlfXBHxyCzWdlrfT1Q1T6vqyVfjXrgycXMj74iIXsbL4/a6XVxeyVLi9mrHQz64OXDkHtE7JWeibrg9dkffAlQ7D51qyVfnyISu/KWunnsj44tZSd2gcvZaz0kVkffEzWBxePZnzwiuWMD16HBzPhmhuz1vyRYWv+RNaa/2/WB2sr3e9pe+H6SsZKG1kffNgQ1P5o1kqfkvXBFwxB7c9nrfRNWR98W9YHPzQEm1/KWun6avZKL1nNWOl1WR/8xawPvmcINi9dy1jpC9eyV/qKrJW+JuuD7xyC2o9mrfRTWR+8K+uD/z4EmxetZ6z0cevZK/3RrJU+JeuDL0hJ7fmIqJd0HtQRV7mF/T2w+dQqKmA98SeO7Kp0Lsr/ic7fTOc+H4yvSRjLBK5JbMEkrokT/wCuiUu2Anqmffi+uNYlO993N5unYl7EOSf0z+A7721ChBUfXh9Yg7xz5nXXrY2+I0fHNmqHPUo7THXeXcNvaZNDqH8iyjdk+6B69yHVPyr4voGycL61y0yC3vgTW5llLB1KeE5HdNZRpornauo5+S3tHstLjDrx/1qtW1beDx/I0DK85IE7p6/cabXDa2dAg7TbYdAq92eXuuUaoKueI12nT+3unNo9fbpdn0FXHXTJ/dfOdstdBLrmcqSrdfZBrbPNs1fH7zhi0DUHuuT+9093y90XdC3kSNfZq67eOb27e2X8jnmDrgXQJfc/gHL3B12cg3Icp8343VWfd5/i2Kp03i18VMHbAdSf3xx4apfrcIQ6+EFc4Hk63Naqzpzvw+/dbTmJd+e3HeXii+P3zSu5TSm51VGGc/a8kywnot4tHRX8ng/Un59MLmlH2S8MIJMFg6aFEchkIVB/jjK5Mn7f4gAyWTRoWhyBTFhnGrrnS0K3rj/Htrw6ft/SADJZMmhaGoFMlgL15yeT06fj9x0dQCZHDZqOjkAmrDMN3fMloVvXn19b7rR1pOUBZLJs0LQ8ApmwzjR0z48p3YsloVvXn+N8shu/b2UAmawYNK2MQCYrgfpzXHfaWHN1AJmsGjStjkAmrDMN3UfHlO7lktCt689xXD4oft/aADJZM2haG4FM1gL15yiT9nq5PoBM1g2a1kcgE9aZhu6VMaX7aEno1vXn1wd32+NyYwCZbBg0bYxAJhuB+nOUSRtDbA4gk02Dps0RyGQT18Q++GvuNJ26eCYKpwAhnZGicwbfaSPcwjvyTP3BttpCfcdc5HJ3W+n+I7+Pudd/qu1jazjxFr972+fd7fXwROdd4mPbNuR2EvXnbV8/od4tdZ1AW8r3N6OslJMyMl8I/bHb5njn+8mE5zbVc3WUOY7nttVz8rvR+R/X/4ud7559bZC+HvuLLDuE01zZ9lPUot7PIPOSnoPyHjdO/DbpA4mifMfjMSWzmpJZHWU4l49ybt2ne5/uQeiO54kjoEWuiX9b5oJ4Ln3+gW45J1/TTlw3fYJSR6T4kA99PU7+gdZM1OuT60cT7fNefhxHfpu0j0dRvnOpttUuKJmNwjau/VHyO8nGvE+3H930+Qu9MyhXlO9hEDqL9lOG4sqW/OtvMvZF6oh/34W6nea7Vvy+BdRJ/WIR8pAyq4jF+mzn2my0N24i1K88/ZOhfnUUdC4qOXvHvOiY0ZohE6eY1aYjby3KW/rNtOKNbfDlzn/GEkagTbed9Cd552y0d0xORr3tGOE7sc5lA/J8dZ9P/I6joGvJ4FfufzOBX4tusUtN4n1L6jnOP1Y/ygFbnNIXSOOBaO+Y8lwrHP2mLfrRpP8KH1JnBWUmO8A01H+1T076r7xzFrKj/8mJvx1H31aLvg6RnfCxBhlImYN9ZLcekN0KZCcyo4/AKy4vXrsWDTojRad8qCt5+XLS6kqUk5ePcybqbbt+NNHH6OXfmYl6fcH9aCrCvzIT9frB+tFUhM2QfpJBaCrCtzGDegahiXb74440HUtBk9BhxZ8yvpj7XGQMUXfUsQr0k07imvZ1xde2FF20jzEb+jG8T+ghhmBbzKtnHMdwK63MixjDjvw2rfiVY4o39gmORc/4Fe27l9+sMw3dS2NKd1HxQv3o9uuDrdOO2KUV28EPQcbrStbkz8nOsZN2baHdyQtnOvLbnlOOK962FG91lKmAX6+1dCLau29DfrPONHSvlYRuv7ZsXeIYc7EjY1Nk3FCyJn/bkEFO9TfZhrEuKThmG7KW+0+b6Jb74YkuXU5r/k5aHDLuvn5rDTqmeCMOpa/VM14v5GtlnWnoPl4Suh3bsuW4nu+E1nPNH/0aci3+fe3E3vvHjfuO7ZMaD1wIOoa2s20p3qiLck+wZ3xyCPMmxVUn0T1VErod23LXUQ/ZgwfWlKzXwbPkBXgB1uXnYuxyfF2WD31NrsmMoTl7YK/ch6jX9IPIuKe9hHXV8F3sJcQEXvb4tLE9xMyec5kTv+25TO/Dm1e8cR9eDf899+Fpm4L8Zp1p6F4aU7oL8G8NRLdfH7zbXuLk9zxvLxEZLytZkz+neIqdtHHOReyPdOS3aen42iZOmz7tJZ45JXQeAPmdlAsjie6VktDt15Z320u84mhlbIqMF5SsyR/HR071N9mGtJdU8F/uvxe47NeAy7ywY1qfYhH+YG8couM+NhVv3ItNe4nnXuzQupi0hzyJ7sWS0O2JoT1jcWTOEBnrWBnhjzYJxia9b2Lv/UXjvmP77KSNYSjCZ+bIr6ljbCjeiHlpL/HEvHrc6rwaaeneKgndjm2564jVz49tkfGykrXwx7WR6/dHDVtnlB99TUfMvJs21qoIHeEQ5Pu0s+cuP3vbE85cd+1VZ85de8P1V5y98ZazN5+bQNVrikzeC7EyiWsM0d0w7vPjvYUhNMQKSGvWclQn2tuA9RYFDbcrKPOXnYYLhZvqNJDSB7hNQGTGcC1P2Lxq0BkpOuVD2Oy5XTDN0C4iNWTaEFjCVq8tHmlDhQvY9pHaHDwNmmpOcnLktw3Vqoq3ecVbHWXoyqs68TsR9YZaVqK96ZT36S6Wbqq03KYm5VZLRCfHpDNNu2nXH6YD9zxuwYnf5oTih1iJbSBl2H8rTvxaY6qK76xzn+5i6M7JhNvSF+K6DwwgjwMGPU7p6BPlkZRCkUflrJWITrnGedTLDMxtHSFsPpFzfVZKdqf5cictxmUf1ltg2F+Iz8vSX2r+NO3MKJqkjpA8LTo5/uQ+eZh0lGcoVSC3Jcm16QJoSpsq0KKT47bhSOdkCjoboFOeY9oOHaIV20YeNNnlw3P7L8M5KwYtNDv/TaVb9qEd+majva4Muhg4N4xyy01MpxW2O8qwYc6rWyWWHUOuNyFPuVYF7Rr/jNodMRvZ7sdRuj8tnbqMsqOezXF0PpUCrskzdI17hvgsg26GSrBOuvTIL5+VMk/qMBPPbT822eXfGp+WO70s7cRtEuPaxzzdwcQKofDGvDH+pOKZfcwaT9rNmSM9pyYMXrWrk+PimRgX8wdseRW1brLPWONS7hd1hIl2z+vjQuieZ/i4Z/rv0NrTb16Q+5wXvLa+JbXxFujUoUyeuj/nRuLwHwcO99riNRH1boHgPMm07VLml4HD/6s/fU3qKJug82Wo2yuFxISqk3LYgGykzPdDNj+NOVbuU0dZU9dGjQuJqYm35PsBXEvCYMTjR9U179iFULjwEui00ml6hbY4+jZ2mRoxQh2RkoF8aEPxTEXgxW8cIhWPlRXFz5Litag0qTr+Q6dqI07gsRLWUWeeeEanmNXp6ZhilraBqpIvbQMcz554ImQbsLZjL+CatscRBxcQUjpULI5nmuw0sTiM9/KcLzzTZHuEQlr4UacmGsXRO6G0taxzn+7i6LZsC1yzV0tEpxWn6JmmWjA0U/9+qIR4fhF4/iMGnqf/zLLzjnLbagjPa/thGW0Xs5G9TbUIeU4kyHNfx7Fp0n2l6PpDOJGx2PLdOtqd49g6MsAL/yTNz8Szco14Vvobt4bIffbFUfua5Br1on5Hfudpcyb2L0A37FnfpI54/fjapHubtNgmen1bNdrp/xzolv3mBeBTH2e/sGVXG2dfw76t3/y0BrVP0Oc1zjZkT3+q4zhuEddovwiPdjhvO+u0VWi/mLbDbRqy02ulZ4wQ1ynGYTUOuNedWg97EdapizAmBl2nPMdEaJ1iuw66Tmn9ogx6mLV26e3q1DkYg1OEHqR1Dta5AHkSWzMGR8pcnDB+2Q5RlO/85bRXrj3GxEei97vWwL+UubQP/177DB1lcEreJ7xyTqmp6/Hn4ZhnHtH5zv2i9JM/3rgfgQ9+KvhOP9y2E9/xu0/4vLtt/z4JOVRQF3m7CPXnHUOkj9eWuk5C3vL9cQe6ZaWclJH2FPrjeazR+U769XML6rk6yjTw3An1nPyWdo/l9yj0ucdj7fU8Tq4R4IepvqRMkt5uxZd561ZaLvOqfmtfS0hn8tzfEFpbqdvJNe7n9kynpnGQtgWHdDa5T1zi2T9DafJ5BI5lu5OUrrSBnPXHs7v3xDTQWhe00ilLGaZKL9uRLUl0T40p3UUc2+ZB97GS0M1j12l3E2xM3fX5wIGznetH8Ey9830Oz9x58O7v1A25TzC0L2rToPkngR8+1MdeVLa9A9SDLTsodeNlda0on5bQrn1a1IOpL2s9mL4nxtgX4VOSd0v/YZ3zkCcxII99kzKvSdANZ1GOfW1aXfPehx/Kh1EBnaLzTfvT1CLO1uOYOqmU+aU+9sOG4k9kvgX+hK8G+Gs48ldR/C2p+qlbv7GPfcGrHRxl0O5324rXDUMGUubXMFe/FeuG9EuuK+8x7kfgg5+K8T1+5qQT31q/zxtb3gtyqKAu8nZv1J+3feFe6t1S171Ah3x/N+wLUk7KSHsK/fEYFRsA6dfP1dRzdZShXeci9Zy2g8Tyewf63HsKsi+cCPDDeD1tM6JOJ+VD64inXTm0jpB2fUR9KKcC11ih3dPWOa9op11B6LTsJYJVaOvRMRPEl55+KfqGhA+tMxBbVqMwRpYyH01Ye0L7ixrA0trPWtaYuSRfzbjFrFkxW8ypSSztNJe1MY6MHY3h5sGPlLmrD4arKTnoWISYP320s6fvxcJwQgvxs5T53AgxnFeOOGJr4XXVkIGU+Xusp/9gYDTajr6VA4Zz8uOccsSHTWIT6VcnDd40zsqLN9Yv75a6iCXl+78Bw0k5KSPtKfTHY3S785306+dq6rk6ytDvd1I9J7+l3WP5fQV97lsFYbjtAD+Mm5IynLM8Yy30njsd20h7o8YFC3ju/BjtdEZrPgvhUSvmytOuEYq5qoBOuWbhUcYHlxmPDupn5H5E3baMsx33fRo6lntcbKCe+6lp29R45SjolDLbCeOb75LnRObEYzquyHOPJrGy5o/7nKXMfRL4c2yHlre+wLmaNjXKQMrcv9KV1wM636mfUad7qHE/Ah/8EI8xbsprvnTEuE0L508bvDVQf954rKLe3VBypp7xkEq3rJSTMtKeQj/9D6RfP6fzBjDGhTgqZP+hHriDPid9yttnOR/gh3hMr6We8QWWH1XbUbiGaDzGOF8p86g+eMw6Dkfnjxr1msh8CvQnW7HWHzKwyjjniBnnWGbamOQZxjcfNXhcMHj01MlCOUfmQae1l9uJpt209rEzffCYto+JzJPsY+SZY6emrnm3jaa9puTAPlTzp8mM/7baRspc16dt9LooMmfbaP96FPXafi3bphOO3E3if8ng/+Y+WNorr5E3lmZb07ZJGUiZZwPXPAdYWeelj+//lHE/Ah/8EEsTTzWc+HaMrW/Svyn9atvgTceo58Ub65d3a5thBd9fBiytbY3SnkL/bNRtK9Kvn1tQz9WjvfZdy4Yovxud/7H8XoA+91PA0kXsCdH8EEtLmSKOG6TeLzSlsW3S9iFl/vuAtk3mJrPwpqffJYQ3qaPJNSs3GeP7y5ybjPZOwZn0vwvOXAY/um2Z85J7Hxk3qvdUSt/h8az0oec9L22pd2uZsM++CeP+Lyt7+bpQcg+UUQ9Kym2TpAdRt47yo7tZtA9fn99GvP47fXCg135Nb/1E+/M3DRlImfdibL4POE9j/vj+h437Efjgp6JkKf8bTnyPCgeSt7LgwDsTcKC0Z1ocuKSeGwYHvh997sPAgZ5x8pUAP8xfpHEgsRN9kdp+F9NelrwmzCVl7e+z7FhF+HeEdvnNGEutcw6KnYgnvDHgluJD500nlqhGNiYjvrgrYe2ZMZ7VOeLLclbT5zCWH1Ht0ueVqyVtblvuVfbS6Rz57TmDRnjTmI5+COY8GCX2TEv3UknorkUe+T9aF1t6vyWPowY9nj6ukDxoC/HMuxSKgWDeJSnzrT5265B8abdOyhdJPXRBXSuDv0dkQtu6J2YK9Q1ijEUlzzLKjhiDerDGQvQlFXFmNfVVoV37VRjzQF1j1LF8ll2ubLKrR7ZvTq7R1kEdJm/dbVq9u4J6NU3MqdXwkV3PXoCKkh3rpJy0XSFSz72ik0ChvZ9mqsvXGt4hfHmeObaq3q3jM6xzbjxtPaRBZM18ifJ/2lEma+rdUpeF1aStdT77Cso8CW19v4S2Jq8PwDNPnOry7aTHFJ5vTbcpbWytDr8Xer61FUMGUuaBaP9LO9+p5xIHPsa4H4EPfir4vp9vbTjeWL+8W+qy8q1931S3rJSTMtKeQv+g+dZW1XPD5Ft7GPrcYzDneOqXjQA/tG1JGet8Zu5fsPadjlIXZB4z7uGwsKC1f8HTpx6K1aR9V64Rz3rpJbRhsj7qazmO3aZ15jvX2vjfzxprdb+z/qxcrxUfmZl5VIid5L+UeWqfdbXhRKejDMw8I7SFyH8pcw3a9+lYN2UN5rp6m3E/Ah/8cF1tRF2ZXmh5RhrgrSx5Rp6NdVXnC5H2FPpHkWfkevS527Cueur6JwL8cB2SMozFKXK9lDmVdWqfkLb50pfy4wnzWZo9qp75OkJxXFaOP9phLIwwDdkI7Z76Sr/9PqF8L0m+SJ7h8LMYF/eFL8wT94QwG3GPZaO18gN64uJQfkCOX71nw9H3kGjnZDtb/daK8yoLLi8A2zY570gdcZ9/HdYCT58Rx1xoTpUyf1btln0j6PM6p8Tadx5X+6sllM2PQzZvhW5gnRtonWU8rjk5930/5mfX0ba1y/U+Qh2RkoF8ToBfL13Lk185w1yfH6B9KAXsDzPj3+R3vzzrOt+rt885tCbT55y0Tk+DdmudHjUW07r8oDn5HPHZDvPERagjUvxEik5P3wXXnEFoKiDPr2veBuKCKMf3Wth7WckshL09x0pIF2Od+3QXR7cVe8Y1u6i9cYPQaa2hXuOSeJ4+38+XEM9/H/D8Fw1b/7jlNPXW/0Nn5GTJqeqJiUI5VRdAZ9nOAS/4LISmJxYhfpZxKHxYuVMnOh3jnpw7tYq5qNb5Tn2C+QVWjPsR+OCnYnx31OP2c6fi+3K1W1bKSZmsuVPn1XPD5E49jD63Avu7p09hO8AP9VUpY8V7SPmQTd5z73PIJs9YFebakmtWvlHLdjbKHDyM/bX2dnjGe/TLrS++Ie5HKPvZTVYu1SLyk8m7df0cQxsllh3HUL88avosrDK0uz6zy7vdte9a18/5Z63EsmO7cz8l90gWmddC7+GciMLnamwYfD06AdOGch4+qDP5UbejD9rSWTz1qJBPiXpUkk+JY7Vs+bXp05r3p8nMuZYUA/+EhP7Dd8lz1r4N4Yu2Xk+drxbgj/qOlHlSH53Pay+Ct85XAa+021h67xng76dCp5N+SVvWTcb9CHzwU1GylP/bTnyPKsafvF2E+vPW+dLE+N8InU/KSRkdqz+KM9Wfhj53E9bWImP8rfwVUoZzcZGxTNpObK33OoaHbfqchPmMvgLGRek13ntNDGEw6qo6ziwUu/T5Cyz+pey5iy0btnxn7I48w9idmsFjxeCx4chjRfEovxug0/JTOdG0S1uUxisN0CFlXtsHj20r/kTmxGPC17bBM8fOtrrm3Taa9m0lB/ahbX+aWlzLktpGyry+T9vodVFkzrYRvlhW28w0/155j5P4nzb4f0sfLO0Vs1W0/+SoIQMp83bgmncAK0t7MQfWHcb9CHzww3mLuPMiJ761/yJvLH1vyKGCusjbfVB/3lha7xmSuu4Necv39wFLSzkpI+0p9MdjWDA46dfPbavn6ihDnK/9LtrPE8vvnehzdwBLV/CevMfEyQA/xNJShvqRJ/bS86S1r0efdWLZPqTMH/XB0lbcpYU3vXyc5EfTTh1Nrllxl9ugfdziLumrE5xJv5xuW8bzU19gfuYVlLX8F1pHzXteCuVBseKGPoVxPz+9l699PSgb7Z56EHXrKD+6m944OI2O8nd9cKCT/a/lrZ+cAK+crxq4LmX+EWPzK8B5Oi4yvj8xvfd+BD74IQ6kDnCh4UDyVhYcKI1j4Tlpz7Q4cFo9NwwO/Cf0OelTReNArdNaOJDYydr3UdRZalnxh6xDtE1adqwi/DtCW0XJM5QXexDsRDxRtD/esn+HMPsqnpMyyx26Q/5ua4/n64AJ9VrPnPn0CXhiJ33mrfwmdtL5zR1p6smFJ/P0lKKJbbCd0AYWNqQ/WvgTvhgDVmS8vtBi4e77JPDnOGe1vMcicwbGf4uGDKTM/ae78noA8IuOzYjvP9S4H4EPfjivUefyyo0Rv9sp/3wb3zAPfCXae955XP8x1J83vtHn/UhdzG0v3x8CfCPlpIy0p9Afj9H1znfSr5/T+c3rKLOO50JnJTAuaQd97qFYnzzn4vUAP1PgR8pwLl50pEmvD0IL66TOzDLW+dyPSpjPrDOLqZNzTfTEaiGdnFhNrjFWTfMd/74LNM/50Nzem3sk6v0kzXVzoMkplq5N01wKmgo4n/aU996iRfCT13utMTinZFaP9p55W4tGe2bLuNId0yRjSejlHHSkRHRa86JX/+b8Rrx1Fmuj07jdmUBbaMzMuCQpc+Vst+y1sFUL9pc25BzFdvW093JOJM209wpvnKed1o6md7uxr1j8sm/f3EeX02NiWskplp20Y1HriRP22uH8KbLTeVaorz+nj+yWArJjv9NzjKddifMJ6YwUnfJhPLfXvJvWJl4EBk97jmIRPreZqBfr9KOpgPw0p4bJT+Nl50hrg6DPXMbGEVyTvmnhp0lck7Y5gGu0nck1oY3rjNd8llYWRfRjR35N3K794my/onDloqJJ23bT0r1QErr92rJ12nEd3Inb/VC0N/+PxZ+TzWMn7VpMe6LX3OnIb5P2Z+FtSvHGHMUV8DvKvfZp6V4qCd1+bdm6JH73ug9v58emyHhdyZr8cS9tTvU32YYxDbKec++t3P8Q7NW/C53cMx8g213q4KdovOXIb3vO0DmWrPzUUoZnYYwy9i0t3WsloduxLVuOWOX8nCEy1r5l+gtq6lo8dj88vff+mnHfsX12GB8ToQ5+itbvHPk1sbqVP13rWt6YN5TTLQmrJ9FdKwndjm2566nDytjWsWOav7hOic26C+vyp404pyg/+ppckxlb/s6D3Xr39ftc3t2eM/R+aktPljJF+RdCejLrTEN3EXb0Qej21u+9fPNav59TsiZ/XjaGtPkzaGs/4kOTa57s+H1VxZvOxcnYWur3VSd+J6Jw3mLWmYbu+ZLQ7deWd+v3Uz68nR+b9FFGAf44PnKqv8k2pH5fwf/z5xjUuuWmal269tfzXN7dtPzL1rqo9105xlwkrousMw3dReWj7ke3Y1u2PGMa9HquffLWGWCcX9Zqe+9XjfvesXlpfKUFtJlrbJ6FefWeSmJe6vej3PuZlu6VktDt2Ja7RWB1kbGOV+Q+HT3+47F7v4LW5TRjt4AzmXbSxoMUoVOm1XnYd53616m0uesZl+F5hlKaOO1x1w2pK0VRvmvMlJLZnJIZ43qIw5z0m0TdjXXu010c3fS1Mb7cOkNp1HTqeGlHmnbTrmtToMkrRtWR3+aE4ofYjm0gZSxbhEe/0GNqCt9Z5z7dxdCdk+1pR1+I6z4wgDwOGPQcGIE8GMtqnVWu9yWWgU5tT/S0X9HGE8L8EznXZ/mIvGy1abEz+7A8x/VW7x8qU3854k9T6phPi06OP7nPdXnSUZ567pLfjIOXa9MF0DSjaJI6QvK06OS4dYppbNM5mYLOddApz1k2TqE9bv+XFmAHYZyJ7I/StHBNazPeKfvyDn3MC0fbzlF1zdPuST40zVLnKM9uFJp0/ZbdsYyys86sZU69KdCu/YCetqAkOyr3M1p+k1H6bULzf9lkZ+Eh7nGcxDV5hj49z9iEI6DbsltM4Npk1Ovj47NS5tfhG353rcu/NT4tW31Z2onxyOPaxzz9WFZONS2DvDH+pOKZfcwaT9ounCM9Pfvn5d16vzfHxR0YF08+aMurqHWTfcYal3pfvKd9nXLUMuN+U7lWxNmYSWtPv3lB50ny3GOS1Mbcv2vlQPbS/Tk3Eod/FDjcay/FRLQ3j7Wez4nNv3ioW/ZP/elrUkdhP/k46i4yl6GOz2f/+XnI5lOYY7Wvmf7WAnzuA+FCYmriLb0XvR8GIx7XPgn67or0iVRBp8yPBZwv2I51cMoX2Pa30A8qdURKBvLZBL9e9nBPfuN2i/vinOJHxwAX4d+2fBHym+uvlQtP7heF348oOnVuLObLom1A+11pG+B49sQTIduAte+xgmvaHmfZvrxjfNLErhBjOM2PrbQxPkX4zxz5bRIXRDm+18KPi0pmxI9F7K2ciPbuO9B5x/fpLpZuy7bANXuhRHQWuI+mGYqbXoV+XxY8fwZ4frNDH/E8/SiWnddzXQ/hedqeLTxvxcKWzXYxa/BTlDwnEuS5r+PYNOm+UnT9IZw4DZnId/rBdfwD52eOBc/4odD8TDwr14hndY5RzkHsi6P2Nck16kWWX5/9I0+bM7F/Abphz/p2BO3xyIPubdJim+j1bcFop+NY3x6N9W1cferj7Be27Grj7GvYt/Wbn9ag9gn6vMbZhuzpT3Ucxy3iGu0XmYMMpMy1B3vv8cN3yXPLhuz0WukZI8R1inPm9SXUwz5ysFv2pgzrlOeYCK1TbNdB1ymtX5RBD7PWLsa2yDV5hjE4RehBWufQdco1YmsdvxN/fiJh/LIdoijf+cvprKr2GBMfiYwxkRnzT0qZl/Xh38mv03KUQc+ZVtLWy4YMpMzPYJ55Rec7z2ukn/yXjPsR+OAn5Ic77sR3/O6Gz7vb9u9tyKGCusjbCdSfdwzRtnq31LUNecv32w92y0o5KaPP5I3nMTlvjPTr5yrquTrK8HyzhnpOfku7x/J7NfrcL2Ht9Yofn4j2nrumfac8dy1Jb7fiy7z3DWi5yG9LZxK+GDNflN9V6hM6tJwou3XQVETeB3m3tgWHdDbmSBA6Pfunzpkxr+QUst3ps+x17kSvnJX3xHyrWhe08pZKGeYkHqXNKC3dtTGlu6izJfOme7UkdMfjuXMEWY/drd75Tt31TuDAzhal88/Gvw+DT3nmYXPdcvIu7hMM7YtaNmj+GPDD6qG976VuXLa9A9SDLTsodeMj6lpRPi2hXfu0qAdTX9Z6MH1PjLEvwqck79bn0hNHiW6sdRxiq79J0A15ti/72qa6FvO85chz6EzgLdApOt+mP00t4mw9jqmTSpm/72M/1JhdZL4C/oSvY+DvmCN/+rzqqqqfuvVX+tgXvNrBUQbtfnccvHJepgykzDcwV/8z1g3pl1xXaof23o/ABz/ElluQ6bYT31q/zxtbnoQcKqiLvF2E+vO2L5xU75a6TkLe8n36ULeslJMy0p5CfzxGG53vpF8/t6Geq6NMA89pu4S2g8Ty+xb6nPQpb/2tEeCH8XpShme9y1oh5UPxGJ77pkPxGMSrco36qOAS6qNyn5jF09apz59fV/Lk+fO0QwhWoa1Hx0wQXxa9d13rDMSW1SiMkaXM1qFenvkJ7S+6Hn4m7Wcta8xckq9m3GLWrJitWTxDLO00l7UxzgZkxX62Dn6kzPck9DO+S57TsQizUXct3wB/Xr4XC8MJLZugU8pcnMCfN4ZzkkGPPVww3IIhAylzKWKmHmJgNNoeL88BwzWc+HbEh01iE+lX2wZvGmflxRvrl3dLXScgb/n+WGA4KSdlpD2F/niMCp4n/fq5DfVcHWXo99tWz8nvRud/LL/L0OcuLwjDHQ/ww7gp6j5Ck2esRUXRpGMbaW/UuKCC/1LmhxLmsxAetWKuPO0aoZirLdAp1yw8yvjgMuPRQf2M3I+o25ZxtuO+T0PHco+LDdRzPzX1M41XpkGnlLmhDx7Tup7InHhMxxV57tEkVtb8cV+AlLmlDx7zyjnurS9wrqZNraqux5/nYG18HvCWjkdu540z7kfggx+uNdw34DVfOmLcpoXzNw3eaCfNG49tqXdLXbSFy/f/Bjym7d7SnkI//Q+kXz+n8wYwxoU4KuRHoB74IvS5lwOPefos1wP8EI/ptdTbTqPXB8tOI+2l8RhjMKXMq/vgMW3f4H4Crueea2JoPwGxit5PENoTtHoBxPeHsMq4xTLTxiTPML552uCxYvDoqZNp/Ud+r4NOay+3E027ae1j70hpHxOZJ9nHyDPHzoa65t02mvYNJQf2oQ1/msz4b6ttpMx7+rSNXhdF5mwb7V+Por22X82/E47cTeK/avD//j5Y2iuvkTeWZlvTtkkZSJk/Aq754z62zU9ktG0y9sLLL+8YW9+kf1P61XGDt23UnzeWbqh3a5thBd8/Diwt5aTM+X3Anf/xGBYMTvr1cxvquXq0175r2RDlN+NiPow+9wlg6Qrek/eY2ArwQywtZagfeWIvPU+msW3S9iFl/mpA2yZzk1l409PvEsKb1NH0WSG0bdIuO265yax9AII7qS8Qd34cOSXlPuNG9Z5K6Ts8V5K6Wd7z0op6t5YJ++xXMe6/a2YvXxdK7oEy6kFJuW2S9CDq1lF+dDeL9uHLuLB0lMpMr2z48dyv6a2f0JdNu4WlCxzEWRszne+MxeI+yHXjfgQ++CEOpA5woeFA8lYWHLg20y2r8Zy0Z1ocWFXPDYMDj6DPSZ8qGgfq3HwWDiR2oi9S2+/KlNeE+MPa32fZsYrw7whtFSVPnuPHHCmDYCfiCW8MuKL40HnTiSWqkY3JiC++J2HtmTGe1Tniy3JW08U8q+lwlz6vc7/T5rblXmUvnc6R354zaIQ3jemY15nnP4wSe/rk0WhdbOnPljys83A9fUUhedCm4DUmKBM9Zpm/SMr8p4S5J0m+tP8m5V2kPle2HIvUfwqI80jsG1wD55U8y56fkvok43SE9rLFn9GfxBwMo/ThhXLvlzl2j+NI5+PQNsS8daAN9e5NJU/SxNxUnvs+ta4t9bNOyol88Fkp8+fAU0+HrWwR7xC+PM/u0mcRS11J58V423Z0Li8dC6vHSd4yWVTvlrrYDrSjUY7EzlLmzWjrWxLamrw+G8+8CbqPkz5QuL1Otyntdc+/h9jr5gwZSJkXo/1/EvY46WfEga827kfgg599e93o7HWvSrDXSXumtdctqOeGsde9DH3u1ZhzPPXLrQA/tBFJGeucY+4DsPZvjlIXZA5l7oWwsKC1D8DTNx3aB0A7KddhoclLL6EtkPVRX8tx7Dat/Sdca+PvnzTW6n5n5lk5U4vc6yn1W3s9395nXb1Q9nrOGTKQMr+F9v1trJuyBnNd/aBxPwIf/HBd3d/rORxvrF/enbTX8wNYV/WeTWlPoX/QvZ7r6rlh9nr+LvrcB7Gueur6xwP8cB2SMsxdWOR6KXMq69S+FW3zpU/izoT5jBhBeA/FQ3nupwjFQ1m58miHsTACdSihfZTxz/WoN+eyXEvy6TEP3CcxLm6CT8kT94QwG3GPZaO18ux54uJQnj2OX733wdH3kGjnZDtb/daKlyoLLi8A2zY579Av/wWsBZ5nXnDMheZUKXNstlv2H0Cf13kf1v7tuO4vl1A2dx7ulv06dAPr/D3rTOBxzW257/sxP7uOtq3dtHswjoNfL13Lk185C1zHn2l8wXb19JGG9gwT51g2KLnPcV+WuCtrnWa8vbVOjxqLWXu8B8lt54jPdphvLUIdkeInUnR6+i645gxCUwG5yE458ttzTliU43st7H1EySyEvT3HSkgXY537dBdHtxV7xjW7qD1mg9Bp5cj2GpfE87RXtPxjRlPj+VcBz5/ufB/n3KDe+n/orJkLITdpUfqZvDspN+qkv5wKP6dO+LDOqbu8M/YK3qdf+Dl1C4YMpMzjMRdd0flOfYL79M8Y9yPwwQ/v759TNxxvrF/eLXVtQ97y/SmHu2WlnJSR9mx0/o/inLonoM+dwfo8inPqqK9KGSveQ8qX8VxY7g/PkrfT054Rsp3RnmHlGvPCOGly1N8EbKbbvKxnIFk5SYvI8yXv1vVzDB0tseyo6/XLR6bPlCpDu+s5oag5Sd5tzUlTSp5llB3bnfsSudewyPwQei8kedC5Wo4afL0yAdPORPY57S9FLhAd50v7HnUWTz0q5FOiHpXkU9rPq3f+Y+bVS4qBf11C/+G75Dlr34bwRVuvp863HuCP+o6UeXMfnc9rL4K3zheK8bf03rcCf78dOp3OWRDf/z3jfgQ++GHfp7/sQovxJ2/bqD9vna+h3i11NSBv+f5e6HxSTsroWP1R5OT4TfS538PaWmSMv/BjxfhzLi4ylknbia31XsfwsE3/IGE+o6+AcVF6jfdeE0MYjLqqjjMLxS61oJNdCPEvxCo61qUMe9ktG7Z8Z+yOPMPYnXWDx02Dx3vQWa67tEVpvGKd5frXffBY6CxX4jF9lit55tg5pq55t42mXefxt/Lxe++3pp0y1DZS5u/6tE3o3CO2jfDFsrSZWefwOuHI3ST+Nwz+v9IHS3vFbBXtP5k2ZCBlvgFc88/AytJenOdrs3vvR+CDH+IExthtO/Gt/Rd5Y+nQObzk7SLUnzeWTnUO72y3rJSTMtKeQv+g5/BqH8tQ5/Ciz0mf8t7r1gjwQywtZagfeWIv7Vuw9vXQdhSyfUiZuY4s++3rYdylhTe9fJxJeJM62nl+cE3w1jHQPm5xl/TVTeI9wo9uW8bzU19gnmPKwPJfjCoPihU3dBH2SDxxdi9f+3pQNto99SDq1lF+dDe9cXAaHeXihHnT0f7X8tZPeCYp5ytLF7gUY/MhwHk6LjK+f7lxPwIf/BAHUge40HAgeSsLDnxsAg6U9kyLAzfUc8PgwMvQ5y4fEQ7UOq2FA0Pn31qxrWXEH7IO0TZp2bGK8O8I7foswXq09xzGQbET8UTR/njL/h3C7At4Tso8JWHtCe3x/AIwocYktI8zHskzBiBkH6edSOsejjS11/8lyKsS7Y3lqKDMjyW0Ad8lz+m4bGLYJfDnlB+hnc92OcAfYyqkzI198I1TXvAdRxn05BwXfDNvyEDKPAtrzbOBX6S9qEe91LgfgQ9+iG+YW3rNiW9HX1cb3+hYi3WDt1HkMKXtUr6/BPhGry86R2BcdLXznfTr55bUc1yXVvFcKC5U2j2W3/PQ516K9clzLl4N8DMFfqRMUee+zyuadFyv5TOWMoxfljKv6GPnknVPeA+tiZ7nIYTWRJ6JpdfJGYPv+PfZ6S7NdR+a23tzZ6PeT9JcV4ccvfalzaCeQWjifi6vuAxHfts2EY6VvN5r9ce6khn7Y1n0mX26i9cfZ/E9/lDPnS0RnVrv8V7Daoom+V3AHtIm1wXi1HcBUzjNd21dqo46uTYzz6mU+fPFbtl3w8Yv96UPhfrVvA8fif1qHnRo/0UN9Hn2K3l3zZCJk9+j6chby/JNTSve2AZ/2EcH120n/YnvtMakV9s59lVzP77wYeHhD/eRXWgtmsV/Pcc68rdTtO1H+LBsP3+a0vYjsuOcYdl+nHD6qbT5aojTlxxpSoPTKScvXTit7WYRNHnZrNKezcb8sl66KvcDD0IT7UBeZzryDMlBaOKZzquONK2koEnooD2ihmuWPiD9lThXn3XCvdIHcM0631Kfm+3Yt1tp5VNE33bkt61T6xzFem8i26+G/6M8rzst3XNjSncBfqaB6Pbrg63Tjmt6K56zDkHGS0rW5M9pzt1JiytWQZOn/c+J3/acsqZ4qyve6ihTAb9e/ibLpyC/WWcauhdLQrdfW7YucfTT7cjYFBmvK1mTP8Zn5VR/k20Y61iCQ+ijk/v3q3fLrdW7dHn5nGei3naXOvgpGs868tu01qBVxZuFGb1986Ez2VlnGrrXSkK3Y1u2HNfz83OGyHhJyZq5bXQsSfz7u+t7768Z9z3jXu6JOoa2P1mYV8owZtvL1pOEeVlnGrqnSkK3Y1vuOuohOxqr67NylsCzxFE+EuvywzF2Ob4uy4e+JtdkeX9c773nuvV62YPT2pKKsAM68tu04m2WFW+MZ6ZdwtP3FjrPiXWmoXtuTOkuwL8yEN1+ffBuu4SXP1rmOpGxzt9E/jxjpWTcRKgjUjKXD30wXnETjvy255RZxVtN8cbYEdolPH3ndUWT9mumpXu+JHT7teXddgmneILzOERkzH0cmj+PODeRZ/yhXYI+c7n/POCfpwP/eGG0eyIO0XEH1rqo9zR7x5aF1sWk2L0kuouKietHtyeG9owF0eu5jtVgroIVdS0euy+o770/a9x3bJ+dtD70InxTjvyaOoaVP1fK0C7hiXlDMfdJWD2J7pWS0O3YlruOWP382BYZH1GyZr4HPf7jsftKw6YY5Udf0xEz76aN9SlCR6CN6Glnz11+9rYnnLnu2qvOnLv2huuvOHvjLWdvPjeBqnX6Qt4LsTKJawypO2rc56fobbvWEUBOXaHlqE60U54J3JZwRw23qfbcXu/lmx++S54j5JF3Umby3xM2Lxh0RopO+RA21xxpSjO0KScvtTKtSaKA8PJTabeUMUyt4kNTK+0RlDRleKWMd+S3DdUOKH6mFW9Ms0CX2QEnfieivTKW36xzn+7i6KZKy6MTpNxCieiUa1V/mnbTrj80YziN6VOO/Lbni0nF24LRBlKG/XfSiV9rTMlv1rlPd3F01xTdGetu6Qtx3esDyGPdoMczBXxIHkwTYZmspNxiieg8gPtCk5cZuB51cWkIm0/kXB+xrfx3mi9Tp01gH5bnuN4yFaPQXpb+UvWnaWdG0SR1hORp0cnxJ/e5LnumOQulhWGaM32EoCdNM4omqSMkT4tOjluv1HxpU0kyvR2PaYo/dAUwTPlf/N18LYaZiT1G00Kz8xvnu2W/3aFvNtrryqCLgXPDKLe2xHRY4bGjDM/lvLpSYtkxtHkZtOkwbeofnMNG6Y4Y5TGdQpN1TKfWqcsoOyvtE7eQb+CaPMN09E6umjbuZsruCupnnXTpkV8+K2W2Og/Gc9v9j3T5t8an5U4vSztxO8K49jFPdzCxQii8MW+Mr4//YR+zxpP2L+VIT0+KO3m3TqfBcXEK4+JjR2x5FbVuss9Y45JzviXHvOnU7nkd7kv3PLdueabyC609/eYFuc95wWuLWVIbr4BOHcrkqftzbiQOfyT6vNdWqomod6sB50mmSpAyTwEOf7Q/fU3qKEzl+xjU7ZWqYSLamz7YOpL5PC6FbH4Acyxxa/yhX7QsYXHE1Nax6EwPm4TBiMePqGuOsQOJR5NYPnmmGnHCiruOvo3dtFv+aUNx8vd7+md34zaK++K84qeufpclzSFxgoz/MqbyY4pI2gZofxXara3RnngiZBuwtj1zu4K2xxEHFxBSOlQsjlds1TBhdp7zhRO/Ta9QSAs/6tgv4scitlZPROGtMqxzn+7i6LZsC1yzF0pEJ8e6/Pcal8TzUkeMl19eQjz/Z3Pdsq8w8Dz9Z5add5TbVkN4XtsPy2i7mI3sbapFyHMiQZ77Oo5Nk+4rRdcfwonW8ZP0g0t/5zi2tmB64Z+k+Zl4Vq5x3dNbNjkHlWWLIGN9qBdJG4T6R542Z2L/AnTDnvWtJwX9Efc2abFN9Pq2YLTTq7C+vRvr27j61MfZL2zZ1cbZ17Bv6zc/rUHtE/R5jbMN2dOf6jiOzWMZ9Dgm1vnLTlsNeizDsiE7K5WwZ4p1rfvEfN5VQj3sEVinPpthnfIcE6F1iu066Dql9Ysy6GHW2qWP+KXOwRicIvQgrXOwTsHQclReXfFHu/0/JYzfmrp+WT58NB33yrXkffFHxhiP2xX+pcy/9uHfya/TcpRBu59MKl6XDRlImQjzzGTnO/eL0k8+b9yPwAc/FeN7/IzXkfbxu4/5vLtt/z4OOVRQF3lroP68Y4iOq3dLXcdBh3yfm+uWlXJSRtpT6I/nMYmXJv36uZp6ro4yjPs+pp6T39Lusfyq6HPzSPPotdd4Itp7lKvwQ1uSlEnS2634Mm/dSstlWtVv7WsJ6Uye+xtCayt1O7nG/dye6dQ0DtK24JDOJveJSzz756ySnd7/E7LdSepU2kCYOtUrZe3+kS7JR4wwJfk4HY0yNaZ0F3FsmAfdqyWhe6bzF0W9drfDne/UXR8GHHgQZeX/oc73w3jmXZ0XUDfkPsHQvqhlg+ZHAT+8fG7ve6kbl23vAPVgyw5K3XhOXSvKpyW0a58W9WDqy1oPpu+JMfZF+JTk3UzPJtdlLRXdWOs4xFZPmOvlk5/ZaO9xpcyHwb7muQ9f61jyexJ0UOdzpqlFnK3HMXVSKfPkBBlbmF1kThuY8LUJ/pz2obaoW+t8WpugU8qcTeDPsx0cZdDud1vglfMyZSBlno65+jqsG9Ivua4817gfgQ9+2PeZ5+G4E99av88bW25DDhXURd5OoP687Qvb6t1S1zbkLd+fA/uClJMy0p6Nzv94jIoNgPTr56rquTrK0K7TUM/Jb9pnnok+99yC7AvHAvwwXk/bjKjTSfnQOuJpVw6tI6RdrlEftXIqyH1iFk9b57SinWu80GnZSwSr0NajYyaILz39UvQNCR9aZyC2rEZhjCxlXpmw9oT2F90FP5P2s5Y1Zi7JVzNuMWtWzNYsniGWdprL2hhHxo7GcMxVJ2Xe0AfDVZUcdCzCbNTrsxL+vHwvFoYj/pf/UuYtI8RwTjLosYfLfL9gyEDKvB3r6TsMjEbb0R05YDgnP84pR3zYJDaRfnXc4E3jrLx4Y/3ybqmrAXnL9/cBw0k5KSPtKfTHY1TwPOnXz1XVc3WUod/vuHpOfku7x/J7J/rcHQVhuK0AP4ybkjLcN+Bpt9P2JJ0vaCLa6/O34h+lzB8lzGchPCrPFmXXqEW9PMvvSdAp1yw8yvjgMuPRQf2M3I9oHXPxrgtkn4aO5R4XG6jnfmraNjVeOQI6pcxn+uAxHXsvMice03FFnns0iZU1f9znLGX+tg8e8zpazltfqIFX2tQoAynzRayNXwLe0vHI7bxxxv0IfPBDPMZ9A+Oa21zj/IrBG+2keeOxSfVuqYu2cPn+LeAxbfemfh9/6H8g/fo5K2+AlNE4is/Jb+qBX0Wf+7b/0azmWqqP3rHWUm87jV4fLDsN4+1YhjGY58vM997jh/tpreNwuJ57romh/QTEKno/QWhP0MsvsBwx4xzLTBuTPMP45iMGjzWDR0+dLKQL0P9q7eV2omk3rX3sRML45rvkOZF5kn2MPHPsVNU177bRtFeVHNiHqv40mfHfVttIme/u0zZ6XRSZs220fz2Kem2/lm3TCUfuJvFfN/jfTeDfEZvtemNp3dYLhgykzIOQv+zBne8h2+ZjjfsR+OCnYnz39Ms7xtY36d+UfrVl8KZj1PPijfXLu7XNsILvj5nvltW2RmlPoT8ew4LBSb9+rqqeq0d77buWDVF+My7m4ehz0qe846MmA/xwfpAy1I9Gbdvk+hGybUqZK/pgaSs3Ge06wrOn3yXkF6SOJtes3GS0y45bbjL63wVnzoEfy7b5GGPvI+NG9Z5KeZbxf9TN8p6XVtS7tUzYZ6/GuL99fi9fF0rugTLqQUm5bZL0IOrWUX50N4v24evz27gG3NoHB3rt1/TWT+jLpt3C0gWeh7H5AuA8jfnj+z9j3I/ABz/EgdQBLjQcSN7KggN/OgEHSnumxYF19dwwOPDF6HM/MyIcqHPzWTiQ2Im+SG2/K1NeE+IPa3+fZccqwr8jtJM++S/XmCNlEOxEPOGNAVcUHzpvOrFENbIxGfHFGxLWnhnjWZ0jvixnNb0FY3lysUufV66WtLltuVfZy57uyG/T0p00pqPuxHnA0zcSwp6sMw3dBcQUDES3D+5tXZwUg0B51A16POfnkDzoW/DMuxSK8aAPV8rc0cduPUiMh44vCPkUrNivUft7OJfJf0/MFOobXMMtfFQ22RFjUA/WWIj27SLOrKa+KrRrvwpjHqhrjDqWj/Ipq+zqke2bk2u0deiYlctypLOi3j2p5EmamFOriP2cFSU71inXJqNevyCflTKP74Cr9n4a2PgWDVl75X+lbV3eLXUlnXPjaeshDSJrqT+07yNvmSyqd0tdFlaTttb57Gmz30Jb/31CW5PXL0FP2Fzo8u2kxxSeb023aQVlvjYaf3Ph+dbmDRlImX9G+/8r7IjaRx3fP7Sw934EPvipGN8dbYH7+dbw/eBCt6yUkzLSnmnzrS2o54bJt/bv6HOHMOd46pebAX5o25Iy1vnM3L9g7TsdpS7IPGa0kVpY0Np36hnPGPIvc36Ra8zB5qWX0IbJ+qiv5Th2e85/lTq41sbfH9f5bmEgKye5tS9XY+W811WdR4W4JOpckzIXdQgOrate+NlRBmaekXlDBlLmP6B974d1U+dhiO9fatyPwAc/XFeZY+ZCyzNC3k6g/rzX1W31bqlrG/KW7w/CuirlpIy0Z6PzfxR5Rr4Hfe5SrKueun4ozwjXISnDWBzP/X797Nu0SVZVGWsP2yMT5rPQHlVr34AnRgjtGyBGoM4o1yyMIPeL2qOqdYWKkmco30vSHlXGbD0O4+LzGBeeuCeE2Yh7LButlR/QExeH8gNSpnrPhvf4Ddk5iXutfmvFeZUFlxeAbZucd6SOuM+fQZ/39BlxzFnzLvvXaxa7Zc/6j8mmte88rvuaEsrmkZDNddANrHMDrXjhUecR0rrooHmE9n0/5mfX0ba1y/U+Qh2RkoF8joFfL13Lk185w7ym+Kmo/wXsDzPj3+R3vzzrOt+rt885tCbT55y0TldAu7VOjxqLaV1+0BwojvhsJ208L2NTvHwXXHMGoYn2cc/5wonfnvPNohzfa2Fva++Nhb09x0pIF2Od+3QXR7cVezajaC4LnXJtEjR5jUvieakjxsu/XkI8fxB4/jcMW3+/nKajjLu0cjZ46/+hM3L65VStq2vemEjHNeq8D9R7CshdZZ7JZ+lnWu9ylFPTE4sQP8s4rKE95L+U+UAfv5SX/8xbX02TO/V/whb6J/A7CXZnfoFPGvcj8MEP1wfO//u5U9Pzxvrl3VJXA/KW75+AX0rKSZmsuVOn1XPD5E79X+hzn8T67OlT2ArwQ31VyljxHlI+ZJMvMg+BFavC3Otyzco3atnORpmDh7G/1t6OvGkaVI+nb4j7Ecp+dpOVS7WI/GTybl0/x9DREsuOY6hfHjV9FlYZ2l2f2eXd7jqHoa6f889iiWXHdud+Su6RLDKvhZVjhnM7yxw1+JruPNjvXA3y+i+dSY+6HX3Qls7iqUeFfErUo5J8ShyrZcuvTZ/WtD9NZs61pBj4lYT+w3fJc9a+DeavEP48db5qgD/qO+fzYyXw57kXwVvnC8X4W3rvCdifLup8535A2rJaxv0IfPDDvkF/2YUW40/eGqg/b50vTYz/zmK3rJSTMjpWf9AYf+0THSbG/77ocy2srUXG+As/Vow/5+IifY8aL3MN0bGIHNNS5sEJ8xl9BYyLou4l98py5gR9Gppv2vMvlPiXcctdTPzC2B15hrE7VYPHSYNHz7NApT7hUX5vgk7LT+VE0y5tURqvWOeT/uc+eCx0JhDxmPC1ZfDMsbOlrnm3Tb8cVOxDW/40tbiWJbWNlLmyT9vodVFkzrYRvliWNrNJg38nHLmbxH/F4P/aPljaK2araP9J3ZCBlLkeuOaZwMrSbjw75oXG/Qh88EMszRi7hhPf2n+RN5Y+ATlUUBd5O4n688bSes+Q1HUC8pbvLwCWlnJSRtpT6I/HsGBw0q+fm1TP1VGGOH9bPaf9PLH8zqHPvRBY2kvPoi6i+SGWljIF5JI3fQt6jwvxmcbStH1ImZf2wdJW3KWFN718nEl4kzqaXLPiLidBe5njLpm/knta5ZrgTPrldNsynp/6AvMzU7ew9DGto+Y9L4XyoFhxQ7+Acf+xxb187etB2Wj31IOoW0f50d30xsFpdJS39cGBTutSy1s/4V4AzleWLvCbGJvvBM4THEeb6geM+xH44If3qQM0nPgeFQ4kb2XBge9PwIHSnmlxYEU9NwwO/B/ocx8ADvSKq7dwoNZpLRxI7CTlQ7GtZdz3IesQbZOWHasI/47QTn+P0Ema5f8g2Il4omh/vLUXP4TZGccoZT7Rx99t7fE8A0xo5RSdU9e8ZRI605fjw8q/W2Q8+5SiiXPgZ/rYwXSbs98Jf/Iscbdn7uylAH+0d0mZv+2Db5ac6Cwq9kTm8SOGDKTMF7HWfAn4RceLtM9fNe5H4IMf4pslyNQrT3/87lWfd7fxzRrkUEFd5I36Z974Zk29W+pag7zl+7eAb6SclJH2FPp5vg7p188tqOe4BjEH/6p6Tn4zj/5X0ee+XdD6tBzgZwr8SJmicqHr9UFoYZ06f82UopFtWl3qvcdPyM6l10nHeS9xL80S6JRrjG/WfMe/3zXbpfmwD83tvbkzUe8naa47DDk62WXae3MPp6CJNo5ZH5pOOfLb5DiMonzndT0GDyuZ1VGG8Yqe54qFxgjr3Ke7OLrj3zIHCL2cO2dKRKc1n3vah0M21gL2QTa5LhCn3n+pW7fTfNfWNQ6jTq7NtIlImSvWu2WbS91y7E/y3+pXnjgk1K9oz9c5zGqgz7NfybsZ5yb1e+XXcuTNPHNlWvHGNnhIAqaz2k76E30c1pj0ajvHvtri+iGyEz6Y40HK/Mc+sgutRTOQnZ5jHfnbKdr2k+STfGwf2S0EZMc5w7L9OOH0UzNRd44inZGiUz7E6V626bQ4nXLy0oXT2m6YC8LLZkWfwSA0LYImL1017Tl3tAMddaRpKQVNzMPrdTYjz4wehCae2U2MKtcsfUD6K3Gu5c/Rezrja0uKhjro5d4AL5t0WvkU0bcd+W1a/jh9pjfbr4b/nva/UN5k1pmG7vqY0l2An2kguv36YOu045reivHNoWjvvmiLP6c5dyctruCZpJ72Pyd+23OKPv/3sOKtHvWe8yv8jvJc6LR0z5eEbr+2bF3i6KfbkbEpMl5VsiZ/a5BBTvU32YaxjiU4hD46uf+GpW65V8Je5bTm7/Dc9Ah18FM0nnXkt2mtQcuKNwszevvmlxRN8pt1pqF7pSR0e8dLOK3n5+cMkfGCkjVznOhYkvj3G5f23l8x7ju2z849UcfQ9icL80oZ7v8sImeS0GTtAU9D91RJ6HZsy11HPWRHY/V5JWvGHUpM67uxLv8Oxi7H12X50Nfkmsy8Pbcvd+v1sgentSUVYQd05Lc9Z+i9LEuKN+6xol1ilHl509JdH1O6i4q56ke3Xx+82y7h5Y+WuU5kPKtkTf48Y6W0v2hQH0zNh6ZTjvy255QZxduc4o2xI7RLePrODyuatF8zLd1HSkK3X1vebZdwiic4j0NExtNK1uSP4yOn+ptsQ9olKvgv978K/HMX8I8XRrsn4hAdd2Cti1KGdgnP2LLQupgUu5dEd1Excf3o9sTQnrEgej3XsRqU81F1LR67X1/ae3/GuO/YPjtpfehF+KYc+TV1jEXFGzEv7RJF7jPQ8bVp6T5aErod23LXEaufH9vMFxUZ/HFt5Po9fbTLP8fXZfnQ13TEzLtpY32oI3itI3FbiM32aWfPXX72tiecue7aq86cu/aG6684e+MtZ28+N4GqdQpW3guxMolrDNlcNO7z4x2+HRpiNCM4dYWWozrRTnkmKqWEO2q4XUGZpc6QCoU71pScpA/IO61UIt6wOY2qTdjspGrvpB3alJOXWpk2vXEB4eWn0m4pY5haxYemVtqjf2jK8Eox68hvG6odUPzo9ObWUQc1XPOYj7WM5Tfr3Ke7OLqp0nKbhpSbKxGdcq3qT9Nu2vWniHQqjvy25wudqmXOaAMpw/476cSvNaZ0OsB9uoulu6bozlh3S1+I614dQB6rBj1O4XaJ8mCaCMtkpY8wKwOd2izuaQauR11cGsLmEznXR2wr/53my9RpE9iH5Tmut0wjKbSXpb9U/WnamVE0SR0heVp0cvzJfa7La47yDKWFWQOdq7jvTdOMoknqCMnTopPjdt2RzrUUdK6DzjXQF3/oCmCY8o0wJ3puP2XYZMWghWbnrdVu2Vs6BXkcHrfLL6prnu4D8qFpZlo3Kzx2lOG5nFePllh2DG1mKIsO06b+wTlslO4IpkKmXjhK96elU5dRdtSzOY7k2hquyTOroN3JVdPG3TwmgqESrJMuPfLLZ6XMz3UGYDy3/crRbjlrfFru9LK0E7cjjGsf83QHEyuEwhvzxvhrimf2MWs8af9SjvT0pI+Xd+t0GhwXb8G4eMyyLa+i1k32GWtc0kVryTFvOvul4ad7nlu3PFP5hdaefvOC3Oe84LXFLKmNeRy8DmXy1P05NxKHvxs43Gsr1UTUu9WA8yRTJUiZP1/pln2fP31N6ihM5fv7RsiDh2x0+mC9PYf95yWQzR9gjpX71FHm1bVR40JiauIt+c70sEkYjHh8Vl1zjB1o8zireJTflk+eqUacsKLn8WW7abf804biGVrvxW/cv+L+eUTxc1j9LkuaQ+IEjv+ypfJjikjaBg4o+dI2wPHsiSdCtgFr2zPlr+1xxMEFhJQOFYvjFVs1TJjdOG7F8QqFtPCjjv0ifixia/VEFN4qwzr36S6Obsu2wDV7rkR0cqzLf69xSTzPdLmT0O/Lgud/AHi+2qGPeJ62OMvOO8ptqyE8r+2HZbRdWEcIFiXPiQR57us4Nk26rxRdfwgnzuK/fKcfXPo7x4S1BdML/yTNz8Szcs065pVj1zrmddS+Jp0ekfg81D/ytDkT+xegG/asbz0p6Jfd26TFNtHr25zRTjNY35pY38bVpz7OfmHLrjbOvoZ9W7/5aQ1qn6DPa5xtyJ7+VMdxbB7LoMcxsc4PLffKgh++S55bMmRnpRL2TLGudZ+Yzx8poR72nuVu2SdlWKc8x0RonWK7DrpOaf2iDHqYtXbJd+IqeYYxOEXoQVrnYJ2CoeWoPJ1Knnb7ZySMX7ZDFOU7fzntlWvJ++KPjLFZyEP4lzI39eHfya/TcpRBz3HKwuuSIQMpcyvmmds637lflH7ylxn3I/DBT8X4Hj+z4cR3/O5Nn3e37d9bkEMFdZG3Y6g/7xiiLfVuqWsLdMj3ly53y0o5KSPtKfTH40PipUm/fq6mnqujDOO+N9Vz8lvaPZbf89HnXoa112uv8US09yjXGvgXfhg3Lv9XjXI6vsx734CWi/y2dCbGua/hu9zz1AHXlIy1nCg77uf2TKemcZC2BYd0NrlPXOLZP6U+kZ3e/xOy3UnqVNpAbvfHs7vE0hHqiBQf8rmnHenClOTjdDTK1JjSXcSxYR50L5eE7ng8H+x8p455qPOduuu7DBx4EM/InHUI17gXV67J3DqNd1B35D7C0L6pJYOnO4AvKp2BGLInlW1vAfVky05K3bmurhXl8xLatc+LejLvaT2ZvinG4Bfhc5J3M32bXJd+KLqz1oGIvT6aoDvORnuPM2W+DPY1z336WgeT35OgkzqhM00t4nA9jqmzSplP9rEvakwvMj8K/oSvdfDntE+1Rd1b59taB51S5tN97A9e7eAog3a/2wCvnJcpAynzN5irP4t1Rfol152vGfcj8MEP+z7Xni0nvrX+nzf2PA45VFAXeWug/rztD8fVu6Wu45C3fP8q7A9STspIewr98RgVGwHp189V1XN1lKHdR9sttJ0klt/n0ee+VpD9YTPAD+2z2qZEnU/Kh+I1PPdVh+I1iGf1kduhnAtyn5jF0xY6rWjnGi90yjViF8bMyH8dU0F8WfTedq1TEFtWozBGljIHO3Rba09o/9GPwA+l/bBljalL8uWMW0ybFdM1i2eIpZ3msjbGkbGjMRxz2UmZjYR+xnfJczpWYTbq9WkJf16+GQvDEf/LfymzncCfN4ZzkkGPvVww3JwhAylzb8RU3bfznRiNtqXTxv0IfPATwnBOfp5TjviwSWwi/WrL4E3jrLx4Y/3ybqnrGOQt3y9Z6ZaVclJG2lPoj8eo4HnSr5+rqufqKEO/4JZ6Tn5Lu7djC9HnTmMN9sRwGwF+GFclZbivwDMWo6Zo0rGPtEdqXFDDc1Lm4QnzWQiPWjFZnnaNUEzWJOiUaxYeJU4pMx4d1A9JfUC3LeNwx30fh471HhcbqOd+a+pnGq/Mgk4p88Q+eEzreiJzvlPHHXnu4SRW1vxxH7SUOdMHj3kdPeetL3Cupk2NMpAyV2NtvAZ4S8crx/dvNe5H4IMf4jHuKxjX3Oca51cM3mgnzRuPTap3S120hcv3ZwGPabs39XuhX9YQ0q+f03kFGAOjcRSfk9/UA69Dn7sVeMzTpzkd4Id4TK+l3nYavT5YdhrG41WivXtn2KYv7IPHko7L4XruuSaG9hsQq+j9BqE9Q5MXQPx/CKuMW6wzMac8QxvorMFjzeDRUyfT+o/8ngad1l5vJ5p209rHfiGlfUxknmQfI88cO1V1zbttNO1VJQf2oao/TWZ8uNU2UubNfdpGr4sic7aN9q/L9Qj8av69jh1L4v+wwf/b+2BpJ2y2642ldVvPGTKQMr8FXPPbfWybH8xo26xApl5+ecfY+yb9m9KvNgzedAx7Xryxfnm3thlW8P0DwNLa1ijtKfTHY1UwOOnXz1XVc/Vor33XsiHKb8bF/C763AeBpT3joyYD/BCjMW5IaPLEXtpHlsa2SduHlLlzQNsmcaeFNz39LiG8SR1Nrlm5y7jGj1vuMmufAHPH6bZlTkzujWTcqN5zKW1POyl1s7znpaPq3Vom7LN/hXG/vLqXrwslN0EZ9aCk3DdJehB16yg/uptF+/D1+W5cA/6xDw702s/prZ/Ql027haULfB1j8xvAeRrzt/Nmre69H4EPfogDqQNcaDiQvJUFB06tdstqPCftmRYHHlbPDYMD/5W52Dq0Fo0Dde4+CwcSO9HuoO13Zcp7Qvxh7f+z7FhF+HeE9pqSZx3XmDNjEOxEPOGNAY8qPnRedWKJamRjMuKLjQ7doThF/azOIV+Ws5y2cZbTc9e69Hnlckmb+5Z7mb10Okd+m5a+qDFdHWU4D3j6RkLYk3WmobuAmIKB6PbBva2Lk2IQKI/DBj2e83NIHvQteOZlCsV40IcrZU4nzJlJ8qV+reMLQj6FmrpWBn8P5zL574mZQn2DGMPCR2WTHTEGx7vGQrRvF3GmNfVVoV37VRjzQF1j1LF8lE9ZZVePbN+cXKOtQ8esXJYjnRX17kklT9LEnFtF7OesKNmxTrk2GfX6BfmslPkT4MAfhY1v3pC1V37Y+F1z6t1SV9I5OJ62HtIgsqZtX+qvOMpkXr2bc0uk5CRtrfPd00f/WrT12YS2Jq/X4JnXQGdz0mMKz8em27SCMs9IwC2ee3681wk9hxwxZCBlbkL7n4MdUfuo4/s/YdyPwAc/FeO7oy1wPx8bvr8Ydka9P1naM20+tjn13DD52J6NPvcTmHM89cv1AD+0bUkZ6/xm7l+w9p2OUhdkbmjq7RYWtPadFulTn1XypK2BOdq89BLaMFkf9bUcx27P+bDcI/MajIE/NtbqfmcB6n25Givnva7qPCrEJVHnmpS5vc+66oWfHWVg5hk5YshAyrwB7ftGrJs6D0N8/53G/Qh88MN1lTlmLrQ8I+StgfrzXlfT5Bn5LayrUk7KSHuOMs/IW9Dn3ol11VPXD+UZ4TokZRiLU+R6qc8ys3xC2uZLX8p7E+azNHtUPfeBhOK4rByAtMNYGEHuF7VHVesKFSXPOq7Rdpjki+QZD3+McXElfGGeuCeE2Yh7LButlR/QExeH8gNy/Oo9G46+h0Q7J9vZ6rdWnFdZcHkB2LbJeUfqiPv8p7AWePqMOOZCc+r5/r/eLftp0Od1jom17zyu+64Syua9a92yn4VuYJ0rOKuueff5QfIIaV100DxC+74f87PraNva5XofoY5IyUA+m+DXS9fy5FfOOK8pfirqfwH7w8z4N/ndLw+7zvfq7XMOrcn0OSet0xXQa63To8ZiWpcfNAeKIz7bSRvPy9gUL98F15xBaKJ93HO+cOK35/yzKMf3Wth7VskshL09x0pIF2Od+3QXR7cVe8Y1+3CJ6JRrk6DJa1wSz0sdMV4+WUCsa1o8/2Lg+ft0vtPW3y+n6SjjLq2cDd76f+gMnX45VQ+ra96YqN+50tR7CshdZZ7ZZ+lnVv5WJzk1PbEI8bOMwxraQ/5LmQd3GL4n5069DHPRIzvfqU8wv8APGvcj8MEP1wfO//u5U9Pzxvrl3Um5Ux+/1i2bV+7UafXcMLlTH40+94NYnz19ChsBfqivShkr3oP6ddnOu+W+div2lxjCsp2NMgcPY3+tvR2e8R5Jejx9Q9yPUPazm6xcqkXkJ5N36/o5hhZLLDvqev3yqOmzsMrQ7npOKGpOkndbc9IBJc8yyo7tzv2U3CNZZF4LvYeTPOgcM4sGXy9KwLQzkX3+/I3IYaLjfGnfo87iqUeFfErUo5J8ShyrZcuvTZ/WtD9NZs61pBj4Vyb0H75LnrP2bTB/hfDnqfNVA/xR35Eyr+2j83nmEvHU+UIx/pbe+wvA37dDp5N+SVvW24z7Efjgh32D/rILLcafvJUlxv+t0Pn6xeoPGuOvfaLDxPi/Hn3ubVhbi4zxF36sGH/OxUXGMmk7sbXe6xgetulvJ8xn9BUwLkqv8d5rYgiDUVfVcWah2KWT0MkuhPiXcctdTPxCPVqeYexO1eBx0uDR8yxQqU94lN/roNPyUznRtEtblMYr1vmk/7sPHgudCUQ8JnxtGDxz7Gyoa95t0y8HFfvQhj9NLa5lSW0jZf6iT9vodVFkzrYRvliWNrNJg38nHLmbxH/F4P8zfbC0V8xW0f6Tw4YMpMzngGs+D6zMsSb3v2ncj8AHP8TSjLFz2ntzSvsv8sbSDcihgrrI2zbqzxtLN9S7pa4G5C3fvwEsLeWkjLSn0B//FgxO+vVz2sdSRxnifO130X6eWH5fRJ/7JrC05163rQA/xNJSpoBc8qZvwdrXMwuaQraP8xiuM6j77esh7rTwppePMwlvUkeTa1bcJdf4cYu7pK9OcCb9crptGc9PfYH5mY+grOW/0Dpq3vNSKA+KFTe0hD0Sl6/v5WtfD8pGu6ceRN06yo/upjcOTqOj3Cth3nS0/7W89RPuBeB8ZekC34Wxef/Od8Zl0qb6YON+BD744X3qABcaDiRvZcGBl653y2o8J+2ZFgdW1HPD4MAm+pz0qaJxoNZpLRxI7ES7gxXbWkb8IesQ11TLjlWEf0dop79H6JRr3G86CHYinijaH2/Zv0OYnXGMUubxCWtPaI/np4AJrZyidXXNWyb1qFcmdSUT4qS6P01mPPuUoolz4BMT2sBqc/Y74U/4Iu72zJ29EOCP9i4pc6YPvllworOo2BOZx2cNGUiZq7HWXAP8YuWFu9W4H4EPfohvFiBTrzz98buXfd7dxjcrkEMFdZE36p9545sV9W6pawXylu/PAr6RclJG2lPoj/uG5Cwn/fq5OfUc1yDm4F9Wz8lv5tG/Dn3u1oLWp6UAP1Pgh+dJCU1F6tZCC+sUWqqqDPe0SZkXZrBzWWui07yXuCYugE69Ts4YfLf1sU6D/X9tkvIOiIwEAA==","debug_symbols":"7d3hjutKlp7pe6nfjQEjuEgGfSuDwaBstwcFNKoNd3mAQaPvfbLsTWaes0Mlba3vfAol33/V1dqZoaeU1HpDmYx//9N//ef//D//n//7L3/9b//6b3/6T//nv//pX/71v/z5b3/5179+/F///qfp/6jtf/23//bf//zXv/8X//a3P/+Pv/3pPy3T9k9/+ue//teP/9S2//inP/23v/zLP3/85+U//q9/+vu/2X/938y1929aKT/+TWvLz/9mfuLfrL1/U8o0//hHpezl53+1PfOvYur+q6jnv4p9//lflaf+VXT/1bbU419ty8/qsTz1r9an/tX21L9qT/2r/Zl/tUxP/avy1L+qT/2r+al/9dRrY3nqtbE89dpYnnptLE+9NpanXhvrU6+N9anXxvrUa2N96rWxPvXaWJ96baxPvTbWp14b61OvjfWp18b21Gtje+q1sT312tieem1sT702tqdeG9tTr43tqdfG9tRrY3vqtdGeem20p14b7anXRnvqtdGeem20p14b7anXRnvqtdGeem20p14b+1Ovjf2p18b+1Gtjf+q1sT/12tifem3sT7029qdeG/tTr439qddGmabn/ll57p/V5/7Z/Nw/i+f+2fLcP1uf+2fbc/+sPffPnnuVlOdeJeW5V0l57lVSnnuVlOdeJeW5V0l57lVSnnuVlOdeJeW5V0l97lVSn3uV1OdeJfW5V0l97lVSn3uV1OdeJfW5V0l97lVSn3uVzM+9SubnXiXzc6+S+blXyfzcq2R+7lUyP/cqmZ97lczPvUrm514l8dyrJJ57lcRzr5J47lXy3CZqeW4XtTy3jVqe20ctz22klud2UstzW6nlub3U8txmanluN7U8t51anttPLc9tqJbndlTLc1uq5bk91fLcpmp5ble1PLetWp7bVy3PbayW53ZWy3Nbq+W5vdXy3OZqubEvsJT9+Gfr/ptP7P7ppwdH1OPTvYh1Ph/8MRd0Hr0v6/GVpynOB9ftWNAy2oLW0Ra0jbagNtqC9rEWVG9sHL1wQWW0BdXRFjSPtqDBrtR1GuxKXafBrtR1GuxKXafBrtR1Gu1KXUa7UpfRrtRltCt1Ge1KXUa7UpfRrtRltCt1Ge1KXUa7UpfRrtR1tCt1He1KXd0/9sv2+evEn78OW/d6LGgdbUHuF/U6TT8evE5rZ0HzNNqCymgLqqMtaB5t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"}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"Vanhelsing::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Vanhelsing::constructor_parameters","fields":[{"name":"feeTo","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"currentFee","type":{"kind":"field"}},{"name":"minCoffinPeriod","type":{"kind":"field"}},{"name":"maxCoffinPeriod","type":{"kind":"field"}},{"name":"minStakePeriod","type":{"kind":"field"}},{"name":"maxStakePeriod","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"Vanhelsing::createCoffin_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Vanhelsing::createCoffin_parameters","fields":[{"name":"stakingToken","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"rewardsToken","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"periodInDays","type":{"kind":"field"}},{"name":"rewardsAmount","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}}]}]},"globals":{"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000006827b230"},{"kind":"string","value":"AddressNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000006827b230"},{"kind":"string","value":"AddressNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}]}],"storage":[{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"minters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"total_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"pending_shields","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"decimals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}]}}]},{"kind":"struct","fields":[{"name":"coffins","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"stakes","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"feeTo","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"currentFee","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"minCoffinPeriod","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"maxCoffinPeriod","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"minStakePeriod","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"maxStakePeriod","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}}]}]}},"file_map":{"4":{"source":"// docs:start:eq-trait\ntrait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n// docs:start:ord-trait\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"24":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field/mod.nr"},"27":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constraint the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::from_slice(domain_generators.as_slice());\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = crate::field::bn254::decompose_hint(scalar);\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"32":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"33":{"source":"mod hash;\nmod aes128;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod embedded_curve_ops;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod convert;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\nmod bigint;\nmod runtime;\nmod meta;\nmod append;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(verification_key: [Field], proof: [Field], public_inputs: [Field], key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\n","path":"std/lib.nr"},"43":{"source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n","path":"std/option.nr"},"52":{"source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n","path":"std/uint128.nr"},"55":{"source":"mod coffin;\nmod stake;\nmod test;\n\ncontract Vanhelsing {\n    use dep::token::Token;\n    use crate::coffin::{Vampire, Coffin};\n    use crate::stake::Stake;\n    use dep::aztec::{prelude::{PublicMutable, AztecAddress, Map}};\n\n    #[aztec(storage)]\n    struct Storage {\n        coffins: Map<Field, PublicMutable<Coffin>>,\n        stakes: Map<Field, PublicMutable<Stake>>,\n        feeTo: PublicMutable<AztecAddress>,\n        currentFee:  PublicMutable<Field>,\n        minCoffinPeriod:  PublicMutable<Field>,\n        maxCoffinPeriod:  PublicMutable<Field>,\n        minStakePeriod:  PublicMutable<Field>,\n        maxStakePeriod:  PublicMutable<Field>,\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(\n        feeTo: AztecAddress,\n        currentFee: Field,\n        minCoffinPeriod: Field,\n        maxCoffinPeriod: Field,\n        minStakePeriod: Field,\n        maxStakePeriod: Field\n    ) {\n        storage.feeTo.write(feeTo);\n        storage.currentFee.write(currentFee);\n        storage.minCoffinPeriod.write(minCoffinPeriod);\n        storage.maxCoffinPeriod.write(maxCoffinPeriod);\n        storage.minStakePeriod.write(minStakePeriod);\n        storage.maxStakePeriod.write(maxStakePeriod);\n    }\n\n    #[aztec(public)]\n    fn createCoffin(\n        stakingToken: AztecAddress,\n        rewardsToken: AztecAddress,\n        periodInDays: Field,\n        rewardsAmount: Field,\n        nonce: Field\n    ) {\n        assert(!stakingToken.is_zero(), \"Staking token is zero\");\n        assert(!rewardsToken.is_zero(), \"Rewards token is zero\");\n        assert(U128::from_integer(rewardsAmount) > U128::from_integer(0), \"Wrong rewards amount\");\n        assert(\n            U128::from_integer(periodInDays) >= U128::from_integer(storage.minCoffinPeriod.read()), \"The period is too short\"\n        );\n        assert(\n            U128::from_integer(periodInDays) <= U128::from_integer(storage.maxCoffinPeriod.read()), \"The period is too long\"\n        );\n        // transfer reward to this contract\n        println(context.msg_sender());\n        println(context.this_address());\n        println(rewardsToken);\n\n        // Token::at(rewardsToken).transfer_public(\n        //     context.msg_sender(),\n        //     context.this_address(),\n        //     rewardsAmount,\n        //     nonce\n        // ).call(&mut context);\n\n        let currentFee = U128::from_integer(storage.currentFee.read());\n\n        let vampire = Vampire {\n            wallet: context.msg_sender(),\n            firstStakeStart: 0, // start day of fist stake\n            numberOfStakers: 0,\n            alive: true\n        };\n\n        let coffin = Coffin {\n            vampire,\n            currentFee,\n            stakingToken,\n            rewardsToken,\n            rewardsReserve: U128::from_integer(rewardsAmount),\n            periodInDays: periodInDays as u64,\n            rewardsPerDay: rewardsAmount as u64 / periodInDays as u64,\n            firstStakeStart: 0 as u64, // start timestamp of fist stake\n            stakesEndMax: 0 as u64, // maximum end time of stakes\n            idleDays: 0 as u64,\n            allStakesNumber: 0 as u64,\n            activeStakesNumber: 0 as u64,\n            isActive: true\n        };\n\n        let coffin_storage = storage.coffins.at(coffin.to_field());\n        let mut coffin_data = coffin_storage.read();\n        coffin_data.activateCoffin();\n        coffin_storage.write(coffin_data);\n    }\n\n}\n","path":"/home/g/Documents/Code/aztec-tutorials/aztec-txe/contract/src/main.nr"},"58":{"source":"use dep::aztec::protocol_types::{address::AztecAddress, traits::{Serialize, Deserialize}};\nuse dep::aztec::{protocol_types::{traits::{ToField, FromField}, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL}};\nuse dep::token::Token;\n\nglobal STAKE_THRESHOLD = 8;\n\nstruct Vampire {\n    wallet: AztecAddress,\n    firstStakeStart: u64,// start day of fist stake\n    numberOfStakers: u32,\n    alive: bool,\n}\n\nimpl Vampire {\n    pub fn is_initialized(self) -> bool {\n        !self.wallet.is_zero()\n    }\n}\n\nglobal VAMPIRE_SERIALIZED_LEN: Field = 4;\n\nimpl Deserialize<VAMPIRE_SERIALIZED_LEN> for Vampire {\n    fn deserialize(fields: [Field; VAMPIRE_SERIALIZED_LEN]) -> Vampire {\n        let wallet =  AztecAddress::from_field(fields[0]);\n        let firstStakeStart = fields[1] as u64;\n        let numberOfStakers = fields[2] as u32;\n        let alive = fields[3] as bool;\n        \n        Vampire {\n            wallet,\n            firstStakeStart,\n            numberOfStakers,\n            alive\n        }\n    }\n}\n\nstruct Coffin {\n        vampire: Vampire,\n        currentFee: U128,\n        stakingToken: AztecAddress,\n        rewardsToken: AztecAddress,\n        rewardsReserve: U128,\n        periodInDays: u64,\n        rewardsPerDay: u64, \n        firstStakeStart: u64, // start timestamp of fist stake\n        stakesEndMax: u64, // maximum end time of stakes\n        idleDays: u64, // idle time in days\n        allStakesNumber:u64,\n        activeStakesNumber:u64,\n        isActive: bool \n}\n\n// impl FromField for Coffin {\n//     fn from_field(field: Field) -> Coffin {\n\n//     }\n// }\n\nimpl ToField for Coffin {\n fn to_field(self) -> Field {\n        self.vampire.wallet.to_field()  +  \n        self.vampire.firstStakeStart as Field  +  \n        self.vampire.numberOfStakers as Field  +  \n        self.vampire.alive as Field  +  \n        self.currentFee.to_integer()  +   \n        self.stakingToken.to_field()   +   \n        self.rewardsToken.to_field()  + \n        self.rewardsReserve.to_integer()   + \n        self.periodInDays as Field  + \n        self.rewardsPerDay as Field  + \n        self.firstStakeStart as Field  + \n        self.stakesEndMax as Field  + \n        self.idleDays as Field  + \n        self.idleDays as Field  + \n        self.allStakesNumber as Field  + \n        self.activeStakesNumber as Field  + \n        (self.stakingToken.to_field())*65536\n    }\n}\n\n#[test]\nfn test_to_from_field() {\n    let field = 1234567890;\n    // let coffin = Coffin::from_field(field);\n    // assert(coffin.to_field() == field);\n}\n\nglobal COFFIN_SERIALIZED_LEN: Field = 16;\n\nimpl Serialize<COFFIN_SERIALIZED_LEN> for Coffin {\n    fn serialize(Coffin: Coffin) -> [Field; COFFIN_SERIALIZED_LEN] {\n        [\n            Coffin.vampire.wallet.to_field(),\n            Coffin.vampire.alive as Field,\n            Coffin.currentFee.lo,\n            Coffin.currentFee.hi,\n            Coffin.stakingToken.to_field(),\n            Coffin.rewardsToken.to_field(),\n            Coffin.rewardsReserve.lo,\n            Coffin.rewardsReserve.hi,\n            Coffin.periodInDays as Field,\n            Coffin.rewardsPerDay as Field,\n            Coffin.firstStakeStart as Field,\n            Coffin.stakesEndMax as Field,\n            Coffin.idleDays as Field,\n            Coffin.allStakesNumber as Field,\n            Coffin.activeStakesNumber as Field,\n            Coffin.isActive as Field\n        ]\n    }\n}\n\nimpl Deserialize<COFFIN_SERIALIZED_LEN> for Coffin {\n    fn deserialize(fields: [Field; COFFIN_SERIALIZED_LEN]) -> Coffin {\n        let vampire = Vampire::deserialize([fields[0], fields[1], fields[2], fields[3]]);\n        let currentFee = U128 { lo: fields[2], hi: fields[3] };\n        let rewardsReserve = U128 { lo: fields[5], hi: fields[6] };\n\n        Coffin {\n            vampire,\n            currentFee,\n            stakingToken: AztecAddress::from_field(fields[3]),\n            rewardsToken: AztecAddress::from_field(fields[4]),\n            rewardsReserve,\n            periodInDays: fields[6] as u64,\n            rewardsPerDay: fields[7] as u64,\n            firstStakeStart: fields[8] as u64,\n            stakesEndMax: fields[9] as u64,\n            idleDays: fields[10] as u64,\n            allStakesNumber: fields[11] as u64,\n            activeStakesNumber: fields[12] as u64,\n            isActive: fields[13] as bool,\n        }\n    }\n}\n\nimpl Coffin {\n    pub fn activateCoffin(&mut self) {\n        assert(!self.isActive, \"Coffin already started\");\n        let vampire = self.vampire;\n        assert(!vampire.is_initialized(), \"Vampire already exists\");\n        self.isActive = true;\n    }\n\n    pub fn addFunds(&mut self, rewardsAmount: Field, currentTime: u64) {\n        assert(U128::from_integer(rewardsAmount) > U128::from_integer(0), \"Wrong amount\");\n        assert(self.getCoffinDaysLeft(currentTime) > 0, \"Coffin expired\");\n\n        // Calculate rewards with old rewardsPerDay till yesterday and store result\n        self.distributeRewards();\n\n        // From today we will count rewardsPerDay with the added funds.\n        self.updateRewardsPerDayAndRewardsBalance(rewardsAmount, currentTime);\n    }\n\n    pub fn getCoffinDaysLeft(&mut self, currentTime: u64) -> u64 {\n        let coffinPeriod = self.periodInDays;\n        if (U128::from_integer(self.firstStakeStart) == (U128::from_integer(0))) {\n            coffinPeriod\n        } else {\n            let mut activeDaysPassed = 0; // How many days coffin was active (had stakes), the current time is not included\n            if ((U128::from_integer(self.stakesEndMax)) < U128::from_integer(currentTime)) {\n                // If last stake finished before present moment we have to count active days\n                // till the end of last stake\n                activeDaysPassed = self.stakesEndMax - self.firstStakeStart + 1;\n            } else {\n                // In case there are active stakes now we just count days till today as active days, the current day is not included\n                activeDaysPassed = currentTime -self.firstStakeStart;\n            }\n\n            activeDaysPassed = activeDaysPassed - self.idleDays;\n\n            coffinPeriod - activeDaysPassed\n        }\n    }\n\n    pub fn updateRewardsPerDayAndRewardsBalance(\n        &mut self,\n        rewardsAmountAdded: Field,\n        currentTime: u64\n    ) {\n        self.rewardsReserve = self.rewardsReserve + U128::from_integer(rewardsAmountAdded);\n        let daysLeft = self.getCoffinDaysLeft(currentTime);\n        if (daysLeft > 0) {\n            self.rewardsPerDay = self.rewardsPerDay + rewardsAmountAdded as u64 / daysLeft; // we store rewardsPerDay multiplied by 1000\n        }\n    }\n\n    pub fn checkPeriod(\n        &mut self,\n        daysLockedUp: Field,\n        minStakePeriod: Field,\n        maxStakePeriod: Field,\n        currentTime: u64\n    ) -> bool {\n        if ((U128::from_integer(daysLockedUp) < U128::from_integer(minStakePeriod))\n            | (U128::from_integer(daysLockedUp) > U128::from_integer(maxStakePeriod))) {\n            false\n        }\n        let coffinDaysLeft = self.getCoffinDaysLeft(currentTime);\n        (U128::from_integer(daysLockedUp) <= U128::from_integer(coffinDaysLeft))\n    }\n\n    pub fn updateStakeNumbers(&mut self) {\n        self.activeStakesNumber += 1;\n    }\n\n    pub fn distributeRewards(&mut self) {}\n\n    pub fn sendRewards(&mut self) {}\n\n    pub fn startStaking(&mut self) {}\n\n    pub fn endStaking(&mut self) {}\n}\n","path":"/home/g/Documents/Code/aztec-tutorials/aztec-txe/contract/src/coffin.nr"},"61":{"source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: Field = 3;\n// ADDRESS_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ADDRESS_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:address_note_def\n// Stores an address\n#[aztec(note)]\nstruct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n\nimpl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/address-note/src/address_note.nr"},"70":{"source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point { x: x_coordinate, y: y_coordinate, is_infinite: false }\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/keys/getters.nr"},"76":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"92":{"source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"95":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/initializer.nr"},"96":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"115":{"source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"133":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\npub fn compute_inner_note_hash<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"154":{"source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<let N: u32>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N as Field)\n}\n\nunconstrained fn storage_write<let N: u32>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<let N: u32>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<let N: u32>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"173":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"175":{"source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"190":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"208":{"source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"212":{"source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"226":{"source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"237":{"source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"278":{"source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"289":{"source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"292":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"309":{"source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_consumption},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): Ensure nullifier collisions are prevented\n    fn compute_note_hash_and_nullifier(self, _context: &mut PrivateContext) -> (Field, Field) {\n        self.compute_note_hash_and_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all","path":"/home/g/Documents/Code/aztec-tutorials/aztec-txe/token/src/types/transparent_note.nr"},"311":{"source":"use dep::aztec::{\n    prelude::{AztecAddress, NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash},\n    note::utils::compute_note_hash_for_consumption, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\n// TOKEN_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}","path":"/home/g/Documents/Code/aztec-tutorials/aztec-txe/token/src/types/token_note.nr"},"325":{"source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}