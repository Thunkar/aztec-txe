{
    "transpiled": true,
    "noir_version": "0.32.0+92ff2fa2e944722e5c3fa43fb3363f093b8f1d12",
    "name": "AuthRegistry",
    "functions": [
        {
            "name": "set_authorized",
            "is_unconstrained": true,
            "custom_attributes": [
                "aztec(public)"
            ],
            "abi": {
                "error_types": {},
                "parameters": [
                    {
                        "name": "inputs",
                        "type": {
                            "fields": [
                                {
                                    "name": "args_hash",
                                    "type": {
                                        "kind": "field"
                                    }
                                },
                                {
                                    "name": "is_static_call",
                                    "type": {
                                        "kind": "boolean"
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "message_hash",
                        "type": {
                            "kind": "field"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "authorize",
                        "type": {
                            "kind": "boolean"
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": null
            },
            "bytecode": "H4sIAAAAAAAC/+2Z227bRhCGV8faUeIkNilK1ImSSMmS6ti+aC/aGL0p0AfoVS+LNslNDkAOyDvmqbIzs8OfDAUFGySEEYQARXL2/2ZmZ0nJY6amZcxR29htYtxmr47MienaQ4P2P4ye2ZOm3RsnpqEm0ZGTFutashd1bMpokLw3M+fOiI2E7cyhprOwHye/GE3qIX10U6MujzPN8ifDRtqO6UM05PcoxUhqOqa8kZc7nLW5I3tLvLGbXtZ0Az047InmWE7pWEW6h5FSSjqZu7+3Cxryd7eaL233JN97tHcklLu0paFw5n6HjzR0nyooQR7b/TSv2ANU7LRcsYdI79Q6/Nsez0T8wIkDnuQZnQELRHMqp4y+hVnRkFEShEBDoKFDX8GsaJ9REvSB9oH2HfoaZkUjRkkQAY2ARg79F2ZFB4ySYAB0AHTg0GcwKzpklARDoEOgQ4c+gVnRmFESxEBjoLFDE5gVHTFKghHQEdCRQ9/ArOiYURKMgY6Bjh36HGZFJ4ySYAJ0AnQixyoS+iOBPxIfRuycrmBWdMooCaZAp0Cn1WjTPNoBxEZ7CbOiM0ZJMAM6AzqrRpvlFfREAn8k9kcif2RcC/KZitn1eQ+zogmjJEiAJkCTarQkf4oPIDba/zArOmeUBHOgc6Bzhz6CWdEFoyRYAF0AXVQTXeRL7Imc+SOBPxL6I31/JPJHBv7IsJZ1Gfkj41rWJahlLp+pmH1uXsCs6JJREiyBLoEuHfoOZkVTRkmQAk2BptVE03xunkjgj8S3NbHIH+nfhorZu+ApzIpmjJIgA5oBzarRsnxOnkjojyz8kfgwYstwDbOiK0ZJsAK6ArqqRlvlP1kHEBpu/IV+5oZBgyZGuxZSc3xhU9M22NYcal0OdS7wSk51hBqmc4i26It2XT7dOf3PthCkuGiw8IJMtHPGf8qVTpeYi0xlGwSWgaYYaVAjbOmYWE+/FdL6JOFfG262N2go13ltuqjNutzrnaTFkZZopTqcSm/vkqxd6L1I+zCC/FZ5w7t2Tlad3Be1s72Ods/cxrYx/c2+Zd+Up3aeFkf0TiLRNv/TZVtYXdFsXMH3IoE/EvojfX8k8kcG/sjQH4n9kZE/Mq5lXYJapj+pJcr0O6pYVMsNU889NqvlqUz8kXktS/njO/nHd/K3Xv1RLRVb+CPLWuYS3NYbJqjlEevf1oqltcwlrOVO/oLpZ1/9J4mGm0/RN9wwaMotgXFqaRc34rHYLu441K4cyrVzWznVkcfSCaroEfqPS2kXL53+yrWL19IuUgtNbx+uOOP/5EqnS8x1prILBJaBphhpUCPQf4QvE+vpn0JanyTM7SLN9kbeJdJrxsL7yl1epg7KtCu3V+20ONJyTnb56vT2rk7ez543HEHH9ZICDj7Q/hERwA6XhB4AAA==",
            "debug_symbols": "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"
        },
        {
            "name": "set_reject_all",
            "is_unconstrained": true,
            "custom_attributes": [
                "aztec(public)"
            ],
            "abi": {
                "error_types": {},
                "parameters": [
                    {
                        "name": "inputs",
                        "type": {
                            "fields": [
                                {
                                    "name": "args_hash",
                                    "type": {
                                        "kind": "field"
                                    }
                                },
                                {
                                    "name": "is_static_call",
                                    "type": {
                                        "kind": "boolean"
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "reject",
                        "type": {
                            "kind": "boolean"
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": null
            },
            "bytecode": "H4sIAAAAAAAC/83X2W7TQBQG4HGWkqZtSmLHseM4ieOlCxGCC5AQVFwg8QI8ARLLDYvEIt6Rp2LOmTn+E1y5mpuoliaeHJ9v5sy4UTWF6io10E2pVNmLImqkjvTNo/ZaSU93Orp5I+VJyOR1qHFex7TdPA6V9JBGNz0aqltaoHob/XH2TEkpY/roF1QJDzQopbYjLo8vHs3k0GgPCjwpVF/tX5RxzLWqY9O6ZjQeZlh27IMhBhyanIHp0r1J+u1kryRZzMnL3k4OjXfSrJeuU1PvKbU+d4f2q94amk6N+nwnPKIdNJO8oh2sd+wcOzbe37GHKG+sB3yn7xOTfG6TfV7khHpgvskZmy7TXwgLDZhSQgAagAaWfkdY6JQpJUxBp6BTS38gLDRkSgkhaAgaWvoeYaEzppQwA52Bziz9jLDQiCklRKARaGTpR4SFxkwpIQaNQWNL1wgLnTOlhDnoHHRu6U+EhSZMKSEBTUATS78gLHTBlBIWoAvQhbk3SeBOfHcStxO9picIC02ZUkIKmoKmzdnSerYWomf7hrDQJVNKWIIuQZfN2Zb1DjoS353E7iR0J8lByB07pt/PH4SFrphSwgp0Bbpqzraqf8UtRM/2AWGha6aUsAZdg64tfYyw0IwpJWSgGWjWLDSrX7EjmbgT350E7mTqTkJ3MnMn0UHey9ydJAd5L/5B1nLHjunfzVeEhW6YUsIGdAO6sfQ3wkJzppSQg+agebPQvF6bI/HdSXxfCwvdyfQ+7Jj+K/iEsNCCKSUUoAVo0ZytqNfkSAJ3krmTuJ3obXiKsNCSKSWUoCVo2ZytrP9ltRCq33uL88wNQ4VDjJxayvpjbEbsKVwVT1XtT3VhcGm68oQOTBdIusK56PqIu9c2/5HeCMrYepy4pRA1rviN+SbLJbMtJe0SE5sHHROkhzLDFd313ngvdsr6r+Dnnl3tjTkc9lR9UPZ40bL8Hrap2j/2nRW7T7p2kKp+O/1b305lq6guPSv4wJtTLPpL7R9AMQRNSxAAAA==",
            "debug_symbols": "5dzdalNRFEXhd8l1kT3n2r99FRGJWiVQUrFRkOK7m2pOUjFUQbEM951pl+la7cU4tPDdrd5cvfr47uVm+/bmdnX5/G51ffN6vdvcbPev7lbpmeLbR2/fr7f3H7jdrT/sVpdyrherq+2b+3/W+uVi9XZzfbW6LOXLxU/DOfdxGM55tOOwSj0zXavSYbpWlx+mX1zcb5TPb+R82qg9vtGIfpgdvR9HRz4zqrJso3EaVWvn3raksrxvqfnB9NklyvFbmNJp2O1wZpnjzDrHmW2OM/scZ44pzrTmONNznBlznJnnOHOOxwPP8XjgOR4PPMfjged4PIg0x5lzPAXFnz8FKdVYhuX0+KHLmenx92xp+da1B78MaP2wdCYuXYhLV+LSjbh0Jy49gEvnRFxaxKWJcclBXJpYxEwsYiYWMROLmIlFzMQiFmIRC7GIhVjEQixiIRaxEItYiEUsxCIWYhELsYiVWMRKLGIlFrESi1iJRazEIlZiESuxiJVYxEosYiMWsRGL2IhFbMQiNmIRG7GIjVjERixiIxaxEYvYiUXsxCJ2YhE7sYidWMROLGInFrETi9iJRezEIg5iEQexiINYxEEs4iAWcRCLOIhFHMQiDmIRB7GISsQkKhGbqESMohKxikrELCoRu7j/isitiWVUIqZRCdlGIdsoZBuFbKOQbfwLVNFTbI1so5BtFLKNQrZRyDYa2UYj22hkG41s419wep5ia2QbjWyjkW00so1GtjGQbQxkG5E+jALZRiRrI6RrIyRsI6RsIyRtI6RtIyRuI6RuIyRvI6RvIyRwI6RwIyRxI6RxIyRyI6RyIyRzI6RzIyR0I6R0IyR1I6R1IyR2I6R2IyR3I6R3IyR4I6R4IyR5I6R5IyR6I6R6IyR7I6R7IyR8I6R8IyR9I6R9IyR+I6R+IyR/I6R/IySAI6SAIySBI6SBIySCI6SCIySDI6SDIySEI6SEIySFI6SFIySGI6SGIySHI6SHIySII6SIIySJI6SJIySKI6SKIySLI6SLY6SLY6SLY6SLY6SL40Rso5EujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEujpEuTiBdnEC6OIF0cQLp4kQitjGQLk4gXZxAujiBdHEC6eIE0sUJpIsTSBcnkC5OIF2cQLo4gXRxAuniBNLFCaSLE0gXJ5AuTiBdnEC6OIF0cQLp4sRvuDhdv9h6/2eSZThyPPwaPw+XoWWfMuK0kEo9Mx3Hd84pH2ettGzf/vH2veu0ff3F9qWFl+n24Gd/frr3UQ7TfcSP04dr+1TXjpmu/Q3H53+6VlNd66mujamuzVNdW6a6tk5y7f7Vp/WHzfrV9dXt/v/cf/Lj9vVuc7M9vNx9fv/9M/vZrw=="
        },
        {
            "name": "_set_authorized",
            "is_unconstrained": true,
            "custom_attributes": [
                "aztec(public)",
                "aztec(internal)"
            ],
            "abi": {
                "error_types": {},
                "parameters": [
                    {
                        "name": "inputs",
                        "type": {
                            "fields": [
                                {
                                    "name": "args_hash",
                                    "type": {
                                        "kind": "field"
                                    }
                                },
                                {
                                    "name": "is_static_call",
                                    "type": {
                                        "kind": "boolean"
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "approver",
                        "type": {
                            "fields": [
                                {
                                    "name": "inner",
                                    "type": {
                                        "kind": "field"
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "message_hash",
                        "type": {
                            "kind": "field"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "authorize",
                        "type": {
                            "kind": "boolean"
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": null
            },
            "bytecode": "H4sIAAAAAAAC/+2ZW2/jRBTHJ2nSbZeSxE2auLm0bpts2tyzbdpduhVPIN554wUBCwsSF4mLEHxEPhVzzszxP64jr86qWBVaS47tM//fnMvYiU/bN1vG7JSN3XrGb/Zqx1TMtj0UaP/YyJk9Kdq9UDEFMTldiXbWldy+rmPTgAZp9uLAT2e2+IyEbnSLfA/8JGb71H5UV0bCC+jjSdU4wzZd+Cl3+5SEubb73kCSeGrYSNsefTgNuf2gj5G+KXxqjx868VMvrgyKzmgqwCpOs+dOGf0DZkGrjJKgCrQKtOrRn2EWtMYoCWpAa0BrHv0GZkEDRkkQAA2ABh79HWZB9xklwT7QfaD7Hv0BZkHrjJKgDrQOtO7RX2AWtMEoCRpAG0Ab7phGqtmI9RbBLOgBoyQ4AHoA9MCjX8IsaJNREjSBNoE2PfobzIK2GCVBC2gLaMuj38IsaMgoCUKgIdAwXZ4wXkclcpCN2AC/glnQQ0ZJcAj0EOhh2tth/GQokSAbsQF+D7OgbUZJ0AbaBtpOe2vH92QGYr39CrOgHUZJ0AHaAdpJe+vED08GYr39DbOgXUZJ0AXaBdpNe+vGN1QGYr29hlnQHqMk6AHtAe2lvfXi502J1PRIqEequeRSf/DA7Pr8CLOgR4yS4AjoEdAjj/4Fs6DHjJLgGOgx0ON0oMdxOTIQ6+1rmAWNGCVBBDQCGqW9RfFtq0QaeqSmR0I90ssFeYeKdXMp8r4eqeqRIJeKtXPJ5dHeY0fZyAnZO3g7v2HQ4JVc3sFJbQbynm5nLBlsJ+zqJOnq1MGRO5URev0/haiPt/zBNp8OvP6Z/XoixbDAwiGZaOeIQ3cl6RIzHIjsDI7dQNEZaVA89OkYUe+zFta9gK8LPtsbp6FpduPa7KA2u8nO5QlyslUtm+TGleJ2jAt24qbZ8dNEmyrpF23XB7e7CSllI4mQJJm929KaZsf9JtyPl7ZTFy9V5dQ1dVKkUp/dmX6ZjyVf2jPn5BWXX2YZoGLDZMWeIbyhnfBzezzHWpH4gpM8pzNgF04zdKfrywsk0CN1PdLWI2E2YsvwBmZBR4ySYAR0BHSU9jaKvziVSEOPNPVIT4/U9Ujw4Onb9VnALOiYURKMgY6BjtPexrE3JVLVI3U9EuSSS6hHerkgb6mYvQv+hFnQCaMkmACdAJ2kvU3ip1SJdLMRG+AMZkGnjJJgCnQKdJr2No2XVomc65FAj9T1SFuPhHrkQo+0clmXph7p5bIuQS65vKVi9rn5CWZBZ4ySYAZ0BnSW9jaL/56mRJp6JNAjjccaWKhH2o+hYvbG+Q5mQeeMkmAOdA50nvY2j3NSInU9MtUjjWzElmEJs6ALRkmwALoAukh7W8Q/VRkI9UvFz9B33DFo0GxId7HwfYhnk13skl0tk66eO3jhTmWEGpvnEF2hf1m5Lnbl9de+i71xXSy119RqXnPEn7grSZeYm4HILuHYDRSdkQbFwxUdIzvT7VpY9wK+lrb4Do3fMq5NCbVZJnuys/76yJbTuupwKNHGJVl61xuRcjaC+BZxY7r0kyxc27n0bWfZtZtl49rNCOlfblr2y2Rqz/vrI3InkegqfmW5Wltdp7n0Bd+IBHqkrkfaeiTUIxd6pKVHGnqkqUd6uaxLkEv6o1y8VP9HFQtzuWHyucfGuTyVXT0yyWUp338nv/9O/q9Xv5lLxaZ6pJJLLsFjvWGCXB6x9mOt2CyXXOq53MnvkP78wX+SqPnaeoO+4Y5Bk2wJjFe7dvHSzbjeLq7Y1SrpyrdzV+5URl65TlBEL9B/vHTt4kuv/8i3i7euXbwlE+0c8Wt3JekSczsQ2Q0cu4GiM9KgeHhBx8hef7EW1r2AuV2kbO/c//xoLyP0VVymbZRplWyvov76yJafZBWvTnnj6sT97HnBE3RcnpHD8B/a/wW/STrIBSsAAA==",
            "debug_symbols": "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"
        },
        {
            "name": "is_reject_all",
            "is_unconstrained": true,
            "custom_attributes": [
                "aztec(public)",
                "aztec(view)"
            ],
            "abi": {
                "error_types": {},
                "parameters": [
                    {
                        "name": "inputs",
                        "type": {
                            "fields": [
                                {
                                    "name": "args_hash",
                                    "type": {
                                        "kind": "field"
                                    }
                                },
                                {
                                    "name": "is_static_call",
                                    "type": {
                                        "kind": "boolean"
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "on_behalf_of",
                        "type": {
                            "fields": [
                                {
                                    "name": "inner",
                                    "type": {
                                        "kind": "field"
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": {
                    "abi_type": {
                        "kind": "boolean"
                    },
                    "visibility": "public"
                }
            },
            "bytecode": "H4sIAAAAAAAC/83Z6W7bRhAH8NVhx4olirpM6rJli7RuO3HsFmgb5EOBvkAfoOiNFj2AHij6in2q7szu8C+ZCI0JAiIEaK1m58fZXUox10lMzZiTurHH1PiDIiYwx/alQucbIy3bqNqzEpiKhFLqJFVNfZqpcYsS61f2x2lqnDupPVBHja6QmAqlHh+ZiqtI5cxRws17ezZSGc4z109Hg364HGInCXrsBb+wr89d8jOffJpWXdCcgp26nIZrMv0bYaFNppTQBG2CNj39DWGhLaaU0AJtgbY8/RZhoQFTSghAA9DA078QFtpmSglt0DZo29OfEBYaMqWEEDQEDT39HWGhHaaU0AHtgHbca540i4mtNkNYaJcpJXRBu6DdfLVuNrcCYqv9ibDQHlNK6IH2QHuefoWw0D5TSuiD9kH7nv6BsNABU0oYgA5AB55+j7DQM6aUcAZ6Bnrm6c8IC42YUkIEGoFG+ZWNsmpK0tKTQE96xcQuw9cIC42ZUkIMGoPGnv6CsNAhU0oYgg5Bh/mBvjPp6ElLTyI9aZYyl7CUgT1xX+yn4F+EhY6YUsIIdAQ6ylcbZctQQGy1bxAWOmZKCWPQMeg4X22cfWuVpKMnLT2J9CQuhTyxYvb+fIew0AlTSpiATkAn+WqTbLGVpKsngZ5EpVRp60mrlLnEpZBhMbmkeAvPyw8MDR6S5amYsk0qT872inWDY8qlpoelzh2euKb00AP5OZJmeO6+PObmpc+/8s/18wonzilEJ4/4uXsn06XYPJW0CxR2HVUXpE6pMKPXGY1hb1iPBvxRxc/2weXwHNO9rY2MfHq4lzjCnKaJOTKHB98F3hJxJX9Dav4yDR7sxP0zIBds7PW71zypF5ODIclkzj+t7+XU3J15PF46Ltx4aQ0vjrjZ8G/rCZczl273VZfldUU+o3XJVuwKK5Ycrtgcw0vsBb90H7Wav+WUfM2TpEtdg127nMQ16TVPAj0J9aSvJ1ExscvwI8JCF0wpYQG6AF3kqy2yXzlK0tGTrp7EehLqSfDep2/vzwuEhS6ZUsISdAm6zFdbZtWUpKknoZ4Epcwl0pO4FPLEitlPwT8IC10xpYQV6Ap0la+2yr6lSjIuJnaANwgLXTOlhDXoGnSdr7bObq2SpHoS6EmoJ309ifTkWk8GpdyXrp7EpdyXoJS5PLFi9nvzK8JCN0wpYQO6Ad3kq22yv/0qSVdPAj3pfKgDi/Sk/yGsmP3g/ICw0C1TStiCbkG3+WrbbE5KEurJWk86xcQuw0uEhe6YUsIOdAe6y1fbZb+qCghtOaqfYN/xmqHBZkN2F5TtdrGJu+L+LvaGS90clrp1eOea0kMbm1skvcT+5c7tYu98/iu/i713u1jaZr6ik0f8sXsn0yVzn0raCxR2HVUXpE6pQEt8N7NX2h/WowHzLpZm+xrjxZ6s/tY92WxR9fs83tjt4eNsa0nklqfyObW4lD9q7uKcdpv6lTSNINs91t/4+nzi/wJdyOVRc+aaM2JMGv7cIxzK/jgx4xaB6pya8X90/g9cmBHJnxwAAA==",
            "debug_symbols": "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"
        },
        {
            "name": "compute_note_hash_and_optionally_a_nullifier",
            "is_unconstrained": true,
            "custom_attributes": [],
            "abi": {
                "error_types": {},
                "parameters": [
                    {
                        "name": "contract_address",
                        "type": {
                            "fields": [
                                {
                                    "name": "inner",
                                    "type": {
                                        "kind": "field"
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "nonce",
                        "type": {
                            "kind": "field"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "storage_slot",
                        "type": {
                            "kind": "field"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "note_type_id",
                        "type": {
                            "kind": "field"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "compute_nullifier",
                        "type": {
                            "kind": "boolean"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "serialized_note",
                        "type": {
                            "kind": "array",
                            "length": 0,
                            "type": {
                                "kind": "field"
                            }
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": {
                    "abi_type": {
                        "kind": "array",
                        "length": 4,
                        "type": {
                            "kind": "field"
                        }
                    },
                    "visibility": "public"
                }
            },
            "bytecode": "H4sIAAAAAAAA/+2b0W7aMBSGHRq6tGlTSAiBQgt0baXdpazt6N1eZnvuXU/aOwwHH/HXdZDRjmcsEQnFie3zf/6PbdIqRGJzJOtPpMpddT4VHw9q812d6387nhhj1S45o0A4O4FwngTCGTNyRgZOeY5VWa47ueY+ic16/FCJnWWiT6Be7AqkqyaqkGh1bKNd1W+nIIDwQsHHqo7Okfqkqh4BUzXYph3cowF34B5pncA92slIK1HmOBj3S7LF5o29no1yLGcqFvGnUMa6KVgYOxxr181Yn53laO2jwxw1q5zy0FWxE7imnJyDPuO3yxPqU+xzbX7EUJ5AW2pHbTrAK49LsV1L5zv6xVq/DNqcQr9E60fXlHfpV1+V5bmbbNtSfEc+1jJ26ib2uxzFmocpjC0Dfb45ulxJjQvx/oi0a/xiyYDp0gnTZk26Ge8ml1cQm+8p6eVZxutpvl1ovmXQ5gq87DnyMgJtYqLrXos+nyevKxmvb+FJ38DU9+BJv0Wf0ZM3GS+38CQ3MOUePMlb9Pk8+fZVxissPCkMTIUHT4oWfT5Pls3zw8DCk4GBaeDBk0GLPuPaaeZJaeFJaWAqPXhStugzevJTxhtaeDI0MA09eDJs0Wf05IeMV1l4UhmYKg+eVC36jHts83wysvBkZGAaefBk1KLP6MlSxhtbeDI2MI09eDJu0WdcO43+tYUn1wamaw+eoOY+3INAuatAuYsD4db1GddOs8dOLDyZGJgmHjxBzX24ywPh1vUZc/ki400tPJkamKYePEHNfbjzQLmLQLmHgXKXgXJXgXIfyvzW9Rmfv5s99sbCkxsD040HT1BzH+48UO5JoNzFgXDr+oxrp/n/4K2FJ7cGplsPnqDmPtyjQLn7B8Kt6zPOwVcZb2bhyczANPPgCWruwz0OlLsKlHsSKHcRKPcwUO4yUO7juvy/3PmBcMt79L7PH+dMy7dUYyINoXEKjTOFcgacc4jRZeOsa8zVHPQWTnzZ5EqfP3S9cK6/XMnYnx2NTca+dxO7+ZvjQcWidxrvDb49gn7EnLcHLTZpPUAuqfwb2lI7akP7BfHL99nuVPlxR7+Z1i+DNnfQ717rR9eUd+nfL1V2Odds5npPbNf5F2BytFc+4/vLAjSExknHDJjmbpieHI63xncaheBdjwvNszPNswza4F7uc289ch+5bbjxOeQM7lH9HO51tPHgb0UWEOMv7Ab1lOo2AAA=",
            "debug_symbols": "ndpRattAGIXRveg5FN/fmhkpWymlOIlTDMEJiVMoJnuv3ZIF5LxpJN237+kw5+lhf/f+6+fh+Pj8Nt1+P09Pz/e70+H5eDmdp823Wv69fXvZHa8v3k6719N0u+3jZtofHy5Poz5upsfD0366be3jx811s359s93AJrAp2GxhM8OmwabDZsAGOthCBzN0MEMHM3QwQwczdDBDBzN0MEMHM3QwQwcNOmjQQYMOGnTQoIMGHTTooEEHDTpo0EGHDjp00KGDDh106KBDBx066NBBhw46dDCggwEdDOhgQAcDOhjQwYAOBnQwoIMBHSzQwQIdLNDBAh0s0MECHSzQwQIdLNDBAh2s0MEKHazQwQodrNDBCh2s0MEKHazQwQodZLORUWRUMtrKaJZRk1GX0ZDRIiMpIlJEpIhIEZEiIkVEiogUESkiUkSkiJIiSoooKaKkiJIiSoooKaKkCMHGiDZGuDHijRFwjIhjhBwj5hhBx4g6Rtgx4o4ReIzIY4QeI/YYwceIPkb4MeKPEYCMCGSEICMGGUHIiEJGGDLikBGIjEhkhCIjFhnByIhGRjgy4pERkIyIZIQkIyYZQcmISkZYMuKSEZiMyGSEJiM2GcHJiE5GeDLikxGgjAhlhCgjRhlByohSRpgy4pQRqIxIZYQqI1YZwcqIVka4MuKVEbCMiGWELCNmWWKWJWZZYpYlZlliliVmWWKWJWZZYpYlZlliliVmWWKWJWZZYpYlZlliliVmWWKWJWZZYpYlZlliliVmWWKWJWZZYpYlZll0QVLMssQsS8yyxCxLzLLELEvMsr5qlpfD793rYXf3tL9ehb1+ez/ef96MvRxPf17+f7n8+xc="
        },
        {
            "name": "set_authorized_private",
            "is_unconstrained": false,
            "custom_attributes": [
                "aztec(private)"
            ],
            "abi": {
                "error_types": {},
                "parameters": [
                    {
                        "name": "inputs",
                        "type": {
                            "fields": [
                                {
                                    "name": "call_context",
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "msg_sender",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                                }
                                            },
                                            {
                                                "name": "storage_contract_address",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                                }
                                            },
                                            {
                                                "name": "function_selector",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 32
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                                                }
                                            },
                                            {
                                                "name": "is_delegate_call",
                                                "type": {
                                                    "kind": "boolean"
                                                }
                                            },
                                            {
                                                "name": "is_static_call",
                                                "type": {
                                                    "kind": "boolean"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                                    }
                                },
                                {
                                    "name": "historical_header",
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "last_archive",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "root",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "next_available_leaf_index",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 32
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                }
                                            },
                                            {
                                                "name": "content_commitment",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "num_txs",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "txs_effects_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "in_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "out_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                                                }
                                            },
                                            {
                                                "name": "state",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "l1_to_l2_message_tree",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "root",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "next_available_leaf_index",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                            }
                                                        },
                                                        {
                                                            "name": "partial",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "note_hash_tree",
                                                                        "type": {
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ],
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "nullifier_tree",
                                                                        "type": {
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ],
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "public_data_tree",
                                                                        "type": {
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ],
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                                                }
                                            },
                                            {
                                                "name": "global_variables",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "chain_id",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "version",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "block_number",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "timestamp",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 64
                                                            }
                                                        },
                                                        {
                                                            "name": "coinbase",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                                                            }
                                                        },
                                                        {
                                                            "name": "fee_recipient",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                                            }
                                                        },
                                                        {
                                                            "name": "gas_fees",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                                                }
                                            },
                                            {
                                                "name": "total_fees",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::header::Header"
                                    }
                                },
                                {
                                    "name": "tx_context",
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "chain_id",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "version",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "gas_settings",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "gas_limits",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                                                            }
                                                        },
                                                        {
                                                            "name": "teardown_gas_limits",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                                                            }
                                                        },
                                                        {
                                                            "name": "max_fees_per_gas",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                                                            }
                                                        },
                                                        {
                                                            "name": "inclusion_fee",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                                    }
                                },
                                {
                                    "name": "start_side_effect_counter",
                                    "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "approver",
                        "type": {
                            "fields": [
                                {
                                    "name": "inner",
                                    "type": {
                                        "kind": "field"
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "message_hash",
                        "type": {
                            "kind": "field"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "authorize",
                        "type": {
                            "kind": "boolean"
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": {
                    "abi_type": {
                        "fields": [
                            {
                                "name": "call_context",
                                "type": {
                                    "fields": [
                                        {
                                            "name": "msg_sender",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                            }
                                        },
                                        {
                                            "name": "storage_contract_address",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                            }
                                        },
                                        {
                                            "name": "function_selector",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                                            }
                                        },
                                        {
                                            "name": "is_delegate_call",
                                            "type": {
                                                "kind": "boolean"
                                            }
                                        },
                                        {
                                            "name": "is_static_call",
                                            "type": {
                                                "kind": "boolean"
                                            }
                                        }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                                }
                            },
                            {
                                "name": "args_hash",
                                "type": {
                                    "kind": "field"
                                }
                            },
                            {
                                "name": "returns_hash",
                                "type": {
                                    "kind": "field"
                                }
                            },
                            {
                                "name": "min_revertible_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "is_fee_payer",
                                "type": {
                                    "kind": "boolean"
                                }
                            },
                            {
                                "name": "max_block_number",
                                "type": {
                                    "fields": [
                                        {
                                            "name": "_opt",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "_is_some",
                                                        "type": {
                                                            "kind": "boolean"
                                                        }
                                                    },
                                                    {
                                                        "name": "_value",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "std::option::Option"
                                            }
                                        }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                                }
                            },
                            {
                                "name": "note_hash_read_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                                    }
                                }
                            },
                            {
                                "name": "nullifier_read_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                                    }
                                }
                            },
                            {
                                "name": "key_validation_requests_and_generators",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "request",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "pk_m",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "x",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "y",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "is_infinite",
                                                                        "type": {
                                                                            "kind": "boolean"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                                            }
                                                        },
                                                        {
                                                            "name": "sk_app",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                                                }
                                            },
                                            {
                                                "name": "sk_app_generator",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                                    }
                                }
                            },
                            {
                                "name": "note_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                                    }
                                }
                            },
                            {
                                "name": "nullifiers",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "note_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                                    }
                                }
                            },
                            {
                                "name": "private_call_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 4,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "contract_address",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                                }
                                            },
                                            {
                                                "name": "call_context",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "msg_sender",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                                            }
                                                        },
                                                        {
                                                            "name": "storage_contract_address",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                                            }
                                                        },
                                                        {
                                                            "name": "function_selector",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                                                            }
                                                        },
                                                        {
                                                            "name": "is_delegate_call",
                                                            "type": {
                                                                "kind": "boolean"
                                                            }
                                                        },
                                                        {
                                                            "name": "is_static_call",
                                                            "type": {
                                                                "kind": "boolean"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                                                }
                                            },
                                            {
                                                "name": "args_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "returns_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "start_side_effect_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "end_side_effect_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                                    }
                                }
                            },
                            {
                                "name": "public_call_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "item",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "contract_address",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                                            }
                                                        },
                                                        {
                                                            "name": "call_context",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "msg_sender",
                                                                        "type": {
                                                                            "fields": [
                                                                                {
                                                                                    "name": "inner",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                }
                                                                            ],
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "storage_contract_address",
                                                                        "type": {
                                                                            "fields": [
                                                                                {
                                                                                    "name": "inner",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                }
                                                                            ],
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "function_selector",
                                                                        "type": {
                                                                            "fields": [
                                                                                {
                                                                                    "name": "inner",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ],
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "is_delegate_call",
                                                                        "type": {
                                                                            "kind": "boolean"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "is_static_call",
                                                                        "type": {
                                                                            "kind": "boolean"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                                                            }
                                                        },
                                                        {
                                                            "name": "args_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "returns_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "revert_code",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 8
                                                            }
                                                        },
                                                        {
                                                            "name": "start_gas_left",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                                                            }
                                                        },
                                                        {
                                                            "name": "end_gas_left",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                                    }
                                }
                            },
                            {
                                "name": "public_teardown_call_request",
                                "type": {
                                    "fields": [
                                        {
                                            "name": "item",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "contract_address",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                                        }
                                                    },
                                                    {
                                                        "name": "call_context",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "msg_sender",
                                                                    "type": {
                                                                        "fields": [
                                                                            {
                                                                                "name": "inner",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            }
                                                                        ],
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "storage_contract_address",
                                                                    "type": {
                                                                        "fields": [
                                                                            {
                                                                                "name": "inner",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            }
                                                                        ],
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "function_selector",
                                                                    "type": {
                                                                        "fields": [
                                                                            {
                                                                                "name": "inner",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ],
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "is_delegate_call",
                                                                    "type": {
                                                                        "kind": "boolean"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "is_static_call",
                                                                    "type": {
                                                                        "kind": "boolean"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                                                        }
                                                    },
                                                    {
                                                        "name": "args_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "returns_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "revert_code",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 8
                                                        }
                                                    },
                                                    {
                                                        "name": "start_gas_left",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                                                        }
                                                    },
                                                    {
                                                        "name": "end_gas_left",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"
                                            }
                                        },
                                        {
                                            "name": "counter",
                                            "type": {
                                                "kind": "integer",
                                                "sign": "unsigned",
                                                "width": 32
                                            }
                                        }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                                }
                            },
                            {
                                "name": "l2_to_l1_msgs",
                                "type": {
                                    "kind": "array",
                                    "length": 2,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "recipient",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                                                }
                                            },
                                            {
                                                "name": "content",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                                    }
                                }
                            },
                            {
                                "name": "start_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "end_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "note_encrypted_logs_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "length",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "note_hash_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"
                                    }
                                }
                            },
                            {
                                "name": "encrypted_logs_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 4,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "length",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "randomness",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"
                                    }
                                }
                            },
                            {
                                "name": "unencrypted_logs_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 4,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "length",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                                    }
                                }
                            },
                            {
                                "name": "historical_header",
                                "type": {
                                    "fields": [
                                        {
                                            "name": "last_archive",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "root",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "next_available_leaf_index",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                            }
                                        },
                                        {
                                            "name": "content_commitment",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "num_txs",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "txs_effects_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "in_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "out_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                                            }
                                        },
                                        {
                                            "name": "state",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "l1_to_l2_message_tree",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "root",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "next_available_leaf_index",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                        }
                                                    },
                                                    {
                                                        "name": "partial",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "note_hash_tree",
                                                                    "type": {
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ],
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "nullifier_tree",
                                                                    "type": {
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ],
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "public_data_tree",
                                                                    "type": {
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ],
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                                            }
                                        },
                                        {
                                            "name": "global_variables",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "chain_id",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "version",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "block_number",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "timestamp",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 64
                                                        }
                                                    },
                                                    {
                                                        "name": "coinbase",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                                                        }
                                                    },
                                                    {
                                                        "name": "fee_recipient",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                                        }
                                                    },
                                                    {
                                                        "name": "gas_fees",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                                            }
                                        },
                                        {
                                            "name": "total_fees",
                                            "type": {
                                                "kind": "field"
                                            }
                                        }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::header::Header"
                                }
                            },
                            {
                                "name": "tx_context",
                                "type": {
                                    "fields": [
                                        {
                                            "name": "chain_id",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "version",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "gas_settings",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "gas_limits",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                                                        }
                                                    },
                                                    {
                                                        "name": "teardown_gas_limits",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                                                        }
                                                    },
                                                    {
                                                        "name": "max_fees_per_gas",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                                                        }
                                                    },
                                                    {
                                                        "name": "inclusion_fee",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                                            }
                                        }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                                }
                            }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
                    },
                    "visibility": "public"
                }
            },
            "bytecode": "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",
            "debug_symbols": "7VvbTuMwEP2XPCPkuXv4ldVqVW4rJFQQl5VWiH/fFGonpaYRaZNmW55Q6JmeOWN3PDNuX6rLq/Pn379u5td3j9XZj5fq9u5i9nRzN6+fXiqQt/893s/mi8fHp9nDU3UWTqqr+WX99/Wkur65varORF5P1mCoZEskqngGmxXAZBaXYIosm8EuQZZgF+UMBpMiWpdgCKEBo73+PKlAD16hjaWQMSQwo9p4CuMWCskDpWVxahSC8Nt7+3DvjaH03gTIyQgibGYAipB2FZBjw7EI6TrcyXIgndE2w3e4Rgg70OqU3AEOATq0shFleHTugJNxyJE0hZXVKqxt8JBdB+34ZAAmMEMc75OBeNRR31M+Qpp+1B1y1CPGtczE01dgcaMCmbyCSN5kbqaOnQ8Scw4BDQxrivXoFNuhKdZgGa8QdE1xPDrFvl/FHuJmuEnKQ2btHQoFrOT9LCIr2FophaNRCoek1FMloNiFpbpYaKqXlRZwERb8DkspLHSsYflKrUvatJp1Hv0YQ/6O4XS7NJLv1ZluN0d6SKujklcH187lPdTTjtAo5RWlC4/Gr3cFNXskNVPXQC029at79NEGajR+YVyHIzahkY5WQGuf014L2NUIIHpMex4pAH5sBDgcmd5PiuQ8uCFq7YmiXjdNG8gttlsrmtD9BOPIQvd1kDBtLzRCFhpXBiL0xsA7YMh1ZJFBdsAg2ARppTukYoZVba4sNMrWHyz9/yXY+BIsWnPOua3Naei0eCApp6SirfQM4X1QLqfl+1fNZNFao926N1xaWS+r2MvK+1iV7/Y6raCXFfayKqYjD2lbeLt8h+L1Zq6U6vuEJtk5JAYenEEGZ9DBGexrDEur2MuquJddLJ+e3KEGLWemWFJTnmLulAG2ZWivCK4wFPKk5/J+JRHnkJandvtzh8Z0BzlhUam0Vjwpb2RS3uikvLFJeRMn5Y1PyRsOo3rTkY0ZJuXNTpNxkYEGZ+DBGWRwBh2coZyvPj8ee5ylHEfg8K05uhKGhOEpYHgKHJ6Chqfg4SlkeArdnqIjk4sNTOGfNPb1JWAaDnJrkhiSVbmx77SCXlbYy4q+bMV0CkUraK7mAVpfF14OcNhOobijldIOiu1ReL1mP+unP7OHm9n57dXiNwaLF5/nF+knB/Xj09/791dq7D8="
        },
        {
            "name": "is_consumable",
            "is_unconstrained": true,
            "custom_attributes": [
                "aztec(public)",
                "aztec(view)"
            ],
            "abi": {
                "error_types": {},
                "parameters": [
                    {
                        "name": "inputs",
                        "type": {
                            "fields": [
                                {
                                    "name": "args_hash",
                                    "type": {
                                        "kind": "field"
                                    }
                                },
                                {
                                    "name": "is_static_call",
                                    "type": {
                                        "kind": "boolean"
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "on_behalf_of",
                        "type": {
                            "fields": [
                                {
                                    "name": "inner",
                                    "type": {
                                        "kind": "field"
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "message_hash",
                        "type": {
                            "kind": "field"
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": {
                    "abi_type": {
                        "kind": "boolean"
                    },
                    "visibility": "public"
                }
            },
            "bytecode": "H4sIAAAAAAAC/+2aWU8jRxDH2xchju1hbGxsbMCA72MwxrAoWbRvecpbpEh5inIrUg4ph6J8xXyqdFV1Tc0waFa12rTQakca3K7+/7qOHttTGkamZMx+xdjjxLijbC2mYfbsSwHOV4ZHdlC0Z6FhCmwawyRQxbGTmRKOQFjGkfVgKhf2T21saIX98i1MlGGtkSkA9EHFIAtDe+6NcLizZ3XMge3TPBxV+EMawD4cyYxd8FP7+hGJ9524Ni6S0dQEq5GmSkNE/xIzo3VEQVAXtC5o3aG/ipnRBqIgaAjaELTh0G/FzGiAKAgCQQNBA4f+KWZGDxAFwYGgB4IeOPQnMTMaIgqCUNBQ0NChv4mZ0SaiIGgK2hS0Sa9ZpJ6PWG9DMTPaQhQELUFbgray3lpxbjmI9faHmBk9RBQEh4IeCnro0K/EzGgbURC0BW0L2s4G2o63XomEeqSuR1p6pJaP2Mr9ImZGO4iCoCNoR9COQ78WM6NHiILgSNAjQY8c+o2YGe0iCoKuoF1Buw79WcyM9hAFQU/QnqA9h34vZkaPEQXBsaDHgh5nK3scfwKUSEOPdPRI3UsuoZfAuvmI3dJ/xMxoH1EQ9AXtC9rPeuvHZVAiR3qk5yWwhh7p6JGuF+Q1FbNXwXdiZnSAKAgGgg4EHWS9DeJiK5GWHgn0SMeLlwM90vCSS9cLcpyPnIO9LvfJtwgauTnmu2FQmzHfMdsVy0aOE3R1knZ1SvCAhjwDN+KnIhrK/fb5Hg7Pnf7C3c9fFlB4CSY4MeIqveN0wXY5ZtmZOKaJIhlhkj0M4XUIMSTCehTwXcFle0sazDGuTUlqc5LuIfYkp5ORqZj0AasMsClCT25DSm6ZKgY7oK8BXrCamKfXLFLOR1IhcTKnn5QTmhLtzON44TijeKGGZxUcVt3b8gjdmXPquspcXnLyEuoSV+xCKjZKV+xSwhvZBT+nS63kthzEE0wSlpoINiHNiIbwmkUCPRLmIzbA38XM6BRREEwFnQo6zXqbxt8cOYj19qOYGZ0hCoKZoDNBZ1lvs/inR4k09UhLj3T1SKhHgreevt2fjZgZnSMKgrmgc0HnWW/z2JsSqeuRUI8EXnLp6JGuF+Q1FbNXwd9iZnSBKAgWgi4EXWS9LeJPqRLp5yM2wEjMjC4RBcFS0KWgy6y3Zby1SmSsRwI9EuqRiR7p6JGpHul52ZeWHul62ZfASy5vULG2Hql5ySV4rhdM4OUjNnkOFbNftD+ImdEVoiBYCboSdJX1topzUiKhHmnrkWY+YstwLWZG14iCYC3oWtB11ts6/onKQaDlKH4sfccDgkaaDe4uQE1d7IhWTHaxEbqK0q6uCF7TkGegsbkS0bX0L1vqYrdOf+O62B11sdBm3sCJEb+gd5wuMLsxyzbimCaKZIRJ9gAl3g7tSsmwHgWMXSxk+yCNXxTXpiy1iUyqJ0t05hGJylwdDKX65JZEzvWTSCUfkfjWcWMauUXW1HZGru2sULtZce1mVdLfPLXtm3RqV6PkDF9JILqOb1WuE7tLmo0r+JNIoEdCPTLRIx09MtUjPT3S1CMtPdL1si+Bl/RnXrzU36GKdbxcMH6usbmXT2Vfjyy8bOX77+T338n/9+63vFSsrUdqXnIJnusFE3j5iE2ea8WWXnIJvVzJb5D+6q3/JEHLUPpS+oYHBE26JTBOTe3ihlZMtotbdLVNu3Lt3DUNeeYldYIsupX+447axTunf+HaxXtqF+/BBCdG/AW943SBuR+zbCeOaaJIRphkD/Bw925o33+WCOtRwNgubqhdfPwoEFsuehQIU5VE2k89Mr5Jd13bKbfXBZN6VnmzFz+rBGSHycJ/QOwwGHfwY2uQSZccNeK+sPrK+cdT/r2UTI34seWWhrBxESKROxMImsY8ucURAMVLGHb/hfM/A+Ak2/IqAAA=",
            "debug_symbols": "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"
        },
        {
            "name": "unconstrained_is_consumable",
            "is_unconstrained": true,
            "custom_attributes": [],
            "abi": {
                "error_types": {},
                "parameters": [
                    {
                        "name": "on_behalf_of",
                        "type": {
                            "fields": [
                                {
                                    "name": "inner",
                                    "type": {
                                        "kind": "field"
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "message_hash",
                        "type": {
                            "kind": "field"
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": {
                    "abi_type": {
                        "kind": "boolean"
                    },
                    "visibility": "public"
                }
            },
            "bytecode": "H4sIAAAAAAAA/+2d20/jRhTG7UB2KYEAC7knEMJ1uWwdspe+tFrap770oZX6VqksyW5Rd4kUQGr/++44PuTL2XFkd2fsHMmWothm5ny/+WZ8fCEju854yX3+uMF6Hvbxhcq8Db69r1u6BmN5Njldg5wucOYIdhF3sEbgOnYU/v0jVKwF35ej0dW/7Zvb/uCf9vDhvj183343fLjt3z3WfAhqLTGlRVPN/c7rPQEBPqQKuG9psm+BWIJ9T4PPYx0WbwP2UduWP3+KwfqHwf2PH4fXf//y8OndYIS+LTrTtdABvqiIzyYRfxre3o+uru8v+/3R4O4OI+Q1UZ2QiMsQ8a+rm9uf+1jryf+L9PtgdHczvMVaTyNGWoJIRseC510UnOmxpuNZZK0ipm/sMHUtttdTsQvQHlM+Ks4V5tkS86wIZQrg44olH13QJibaRs043Lk54bY9RlbtxL5YC7jJ41XmNbavCB4Y0vewD/OgVwTddWi76dPsGvSpCyzroL9pxfvetTrmNpzpZVau2wSmZ1aYxrnOTnvH43gLYueMxX7VU/FKzLcN5lsRymyBlyVLXrqgTUy0XQrRN+fJm5cqXjmCJ2UNUzkFT8oh+uY8ef1exatE8KSiYaqk4EklRN/gOPGvFaoRPKlqmKopeFIN0Tc4Tnz9WgRPahqmWgqe1EL0DXryRsWrR/CkrmGqp+BJPUTfoCevVLxGBE8aGqZGCp40QvTNeXLhX1c1I3jS1DA1U/CkGaJvMMf61yetCJ60NEytFDxphegbPHauVbztCJ5sa5i2U/AENeNwl4Vyl4RyN+aEm+ubO3Z6fo7dieDJjoZpJwVPUDMOd2NOuLm+wTw4UPHaETxpa5jaKXiCmu0Y3GWh3CWh3A2h3FWh3K2MO1HuecknXN/gfYN/z70bwZNdDdNuCp6gZhzu+pxwc32D53n/eWwngicdDVMnBU86IfoGnxX41z57ETzZ0zDtpeAJasbhbgjl3hLKXRLKXRbKXRHKXRXKXRPKXRfKLTV/N4Vyt4RyS83fUs+XUsf3vOQTrm/wfsf/lep+BE/2NUz7KXiyH6Jv8H7e/3/xQQRPDjRMByl4gppxuJtCuUtCuRtCubNxkix3VSh3RSh3lk++jpvrG7w+ea3iHUbw5FDDdJiCJ6gZh7silLsslHtPKHdjTri5vsHfzfj6RxE8OdIwHaXgCWrG4e7MCbfaR3NsLl3bTL1+gTGRhsM4HcZZgPVN8O4YYuSNcXoe9tUx6D234ounHfe0/dy6fu9axT611DYV+8xObP93dudBrHwQ+0zj2wvQdw332zmLTVrn0Je0/oM7KUvlqAzlC+JXc/1OgnXk5/WOWL0ilDmBemesHm1Tvyv/XkIOsDXWoox1Nb+PjvPvnQnTsRWm8bzmnDO9zMpLmBPW7DB1LbbX0/VBjrUNcyDOM7V5vjpmTLQ96zw7i3thTrgt6j/OEc4xzWXmi1qoH/PML+JagDa4UB7n255Yacd4vm2ca4MTYLJ1XrbX3vExeMratsnaVoQy+FsPW+dqF7SJibZRMw53SSh3WSh3RSh3VSh3TSh3XSh3Qyh3Uyh3Syi31Pwt9Xwp9bjcFsot1e8dodxZPkmWW+r4lnodK/U8n12fJMvdFsot9X5nVyh3Ryi31PNO9nwwWe7s+WCy3NnzwWS5s+eDyXJnzweT5c7u55Plljq+peaTPaHc+0K5pY7v7PlgstzZOEmWW+p9g9T7tCyfJMt9IJRb6viWet8g9XpQ6nF5KJR7Xp7bq330e+Q/c7aZxnOTkIk0HMbpMM4CrJ+AdzjnxfTcJNI7A71zK76M+4qPH9o+t64/npv0raW2qdiendj+77u7QSyam+RpfLsAfddwv3VZbNLqQl/S+h+5SVkqR2UoXxC/mpv0IlhHfl7vlNUrQhmc0+SxerRN/a78+w1ygK2xFmWsq7kQdJzT3CSFtgJ1aFli22+NcI7Hra3jXeWzBWd6mZUHcSxbmufXXXYm70C8ux+Orj4Mfh1cPb5o0wVkV/PthjQHm5GH9WNY56875PVmLRancPmHd9iUPpyeZvO1i3nwTsVeZp4tQplPweG77ny5YCyqR/1JMVehXfiG4wXWZurvHPiBwzkHZc9YnYLzpYcFZzK1iv6mXmX6H09X0fx6eQAA",
            "debug_symbols": "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xUmki5NIFyeRLk4iXZxEujiJdHES6eIk0sVJpIuTSBfHSBfHSBfHSBfHSBfHhdhGI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI10cI12chnRxGtLFaUgXpyFdnFaIbWxIF6chXZyGdHHaQRfHpdQDU9tepr6t1v3PWDk8Y7fizLE7HOuPbmP36O564HQbu1Uz9mdLWzmbLZYfy9A3Z+/uZW7zXurQbsGxci8HbZ+t3ku83MvqvejlXlbvpb7cy+q95Mu9rN6Lf6J76XV3L3rovbSXe1m9l/4/38uYY38v88CmrnMZ494dKsoy/UBPP8nTq6CnD/T0Qk9fIdO7rU2f6OkNnf72q7/OPlyc/fHu/Pr2X3z55sfL1zcXV5d3X978/f7rd27P/gM="
        },
        {
            "name": "consume",
            "is_unconstrained": true,
            "custom_attributes": [
                "aztec(public)"
            ],
            "abi": {
                "error_types": {},
                "parameters": [
                    {
                        "name": "inputs",
                        "type": {
                            "fields": [
                                {
                                    "name": "args_hash",
                                    "type": {
                                        "kind": "field"
                                    }
                                },
                                {
                                    "name": "is_static_call",
                                    "type": {
                                        "kind": "boolean"
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "on_behalf_of",
                        "type": {
                            "fields": [
                                {
                                    "name": "inner",
                                    "type": {
                                        "kind": "field"
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "inner_hash",
                        "type": {
                            "kind": "field"
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": {
                    "abi_type": {
                        "kind": "field"
                    },
                    "visibility": "public"
                }
            },
            "bytecode": "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",
            "debug_symbols": "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"
        }
    ],
    "outputs": {
        "globals": {
            "storage": [
                {
                    "fields": [
                        {
                            "name": "reject_all",
                            "value": {
                                "fields": [
                                    {
                                        "name": "slot",
                                        "value": {
                                            "kind": "integer",
                                            "sign": false,
                                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                                        }
                                    }
                                ],
                                "kind": "struct"
                            }
                        },
                        {
                            "name": "approved_actions",
                            "value": {
                                "fields": [
                                    {
                                        "name": "slot",
                                        "value": {
                                            "kind": "integer",
                                            "sign": false,
                                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                                        }
                                    }
                                ],
                                "kind": "struct"
                            }
                        }
                    ],
                    "kind": "struct"
                }
            ]
        },
        "structs": {
            "functions": [
                {
                    "fields": [
                        {
                            "name": "parameters",
                            "type": {
                                "fields": [
                                    {
                                        "name": "on_behalf_of",
                                        "type": {
                                            "fields": [
                                                {
                                                    "name": "inner",
                                                    "type": {
                                                        "kind": "field"
                                                    }
                                                }
                                            ],
                                            "kind": "struct",
                                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                        }
                                    },
                                    {
                                        "name": "inner_hash",
                                        "type": {
                                            "kind": "field"
                                        }
                                    }
                                ],
                                "kind": "struct",
                                "path": "AuthRegistry::consume_parameters"
                            }
                        },
                        {
                            "name": "return_type",
                            "type": {
                                "kind": "field"
                            }
                        }
                    ],
                    "kind": "struct",
                    "path": "AuthRegistry::consume_abi"
                },
                {
                    "fields": [
                        {
                            "name": "parameters",
                            "type": {
                                "fields": [
                                    {
                                        "name": "on_behalf_of",
                                        "type": {
                                            "fields": [
                                                {
                                                    "name": "inner",
                                                    "type": {
                                                        "kind": "field"
                                                    }
                                                }
                                            ],
                                            "kind": "struct",
                                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                        }
                                    }
                                ],
                                "kind": "struct",
                                "path": "AuthRegistry::is_reject_all_parameters"
                            }
                        },
                        {
                            "name": "return_type",
                            "type": {
                                "kind": "boolean"
                            }
                        }
                    ],
                    "kind": "struct",
                    "path": "AuthRegistry::is_reject_all_abi"
                },
                {
                    "fields": [
                        {
                            "name": "parameters",
                            "type": {
                                "fields": [
                                    {
                                        "name": "approver",
                                        "type": {
                                            "fields": [
                                                {
                                                    "name": "inner",
                                                    "type": {
                                                        "kind": "field"
                                                    }
                                                }
                                            ],
                                            "kind": "struct",
                                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                        }
                                    },
                                    {
                                        "name": "message_hash",
                                        "type": {
                                            "kind": "field"
                                        }
                                    },
                                    {
                                        "name": "authorize",
                                        "type": {
                                            "kind": "boolean"
                                        }
                                    }
                                ],
                                "kind": "struct",
                                "path": "AuthRegistry::_set_authorized_parameters"
                            }
                        }
                    ],
                    "kind": "struct",
                    "path": "AuthRegistry::_set_authorized_abi"
                },
                {
                    "fields": [
                        {
                            "name": "parameters",
                            "type": {
                                "fields": [
                                    {
                                        "name": "on_behalf_of",
                                        "type": {
                                            "fields": [
                                                {
                                                    "name": "inner",
                                                    "type": {
                                                        "kind": "field"
                                                    }
                                                }
                                            ],
                                            "kind": "struct",
                                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                        }
                                    },
                                    {
                                        "name": "message_hash",
                                        "type": {
                                            "kind": "field"
                                        }
                                    }
                                ],
                                "kind": "struct",
                                "path": "AuthRegistry::is_consumable_parameters"
                            }
                        },
                        {
                            "name": "return_type",
                            "type": {
                                "kind": "boolean"
                            }
                        }
                    ],
                    "kind": "struct",
                    "path": "AuthRegistry::is_consumable_abi"
                },
                {
                    "fields": [
                        {
                            "name": "parameters",
                            "type": {
                                "fields": [
                                    {
                                        "name": "reject",
                                        "type": {
                                            "kind": "boolean"
                                        }
                                    }
                                ],
                                "kind": "struct",
                                "path": "AuthRegistry::set_reject_all_parameters"
                            }
                        }
                    ],
                    "kind": "struct",
                    "path": "AuthRegistry::set_reject_all_abi"
                },
                {
                    "fields": [
                        {
                            "name": "parameters",
                            "type": {
                                "fields": [
                                    {
                                        "name": "approver",
                                        "type": {
                                            "fields": [
                                                {
                                                    "name": "inner",
                                                    "type": {
                                                        "kind": "field"
                                                    }
                                                }
                                            ],
                                            "kind": "struct",
                                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                        }
                                    },
                                    {
                                        "name": "message_hash",
                                        "type": {
                                            "kind": "field"
                                        }
                                    },
                                    {
                                        "name": "authorize",
                                        "type": {
                                            "kind": "boolean"
                                        }
                                    }
                                ],
                                "kind": "struct",
                                "path": "AuthRegistry::set_authorized_private_parameters"
                            }
                        }
                    ],
                    "kind": "struct",
                    "path": "AuthRegistry::set_authorized_private_abi"
                },
                {
                    "fields": [
                        {
                            "name": "parameters",
                            "type": {
                                "fields": [
                                    {
                                        "name": "message_hash",
                                        "type": {
                                            "kind": "field"
                                        }
                                    },
                                    {
                                        "name": "authorize",
                                        "type": {
                                            "kind": "boolean"
                                        }
                                    }
                                ],
                                "kind": "struct",
                                "path": "AuthRegistry::set_authorized_parameters"
                            }
                        }
                    ],
                    "kind": "struct",
                    "path": "AuthRegistry::set_authorized_abi"
                }
            ]
        }
    },
    "file_map": {
        "101": {
            "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/returns.nr",
            "source": "#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<let N: u32>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"
        },
        "106": {
            "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
            "source": "use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(address: Field, storage_slot: Field, block_number: Field, length: Field) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field\n    )\n}\n\nunconstrained pub fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
        },
        "107": {
            "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr",
            "source": "#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<let N: u32>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"
        },
        "112": {
            "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
            "source": "use dep::protocol_types::{abis::{function_selector::FunctionSelector}, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n"
        },
        "113": {
            "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
            "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\nunconstrained pub fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\nunconstrained pub fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\nunconstrained pub fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\nunconstrained pub fn get_version() -> Field {\n    get_version_oracle()\n}\n"
        },
        "115": {
            "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
            "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; 2] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
        },
        "151": {
            "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr",
            "source": "use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"
        },
        "153": {
            "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
            "source": "use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"
        },
        "154": {
            "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
            "source": "use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{enqueue_public_function_call_internal, set_public_teardown_function_call_internal}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, gas::Gas,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, public_call_stack_item::PublicCallStackItem,\n    public_call_stack_item_compressed::PublicCallStackItemCompressed, read_request::ReadRequest,\n    note_hash::NoteHash, nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        let call_request = PublicCallRequest { item, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            item,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"
        },
        "155": {
            "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
            "source": "use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{\n    execution::{get_chain_id, get_version, get_contract_address, get_block_number},\n    storage::{raw_storage_read, storage_read}\n};\n\nstruct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"
        },
        "156": {
            "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
            "source": "use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<let N: u32>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N as Field)\n}\n\nunconstrained fn storage_write<let N: u32>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<let N: u32>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<let N: u32>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"
        },
        "175": {
            "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
            "source": "use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"
        },
        "177": {
            "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
            "source": "use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"
        },
        "210": {
            "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
            "source": "use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"
        },
        "27": {
            "path": "std/hash/mod.nr",
            "source": "mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constraint the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::from_slice(domain_generators.as_slice());\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = crate::field::bn254::decompose_hint(scalar);\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n"
        },
        "291": {
            "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
            "source": "struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
        },
        "55": {
            "path": "/home/g/Documents/Code/aztec-tutorials/aztec-txe/contracts/auth_registry_contract/src/main.nr",
            "source": "contract AuthRegistry {\n    use dep::aztec::{state_vars::{PublicMutable, Map}, protocol_types::address::AztecAddress};\n    use dep::authwit::auth::{IS_VALID_SELECTOR, compute_authwit_message_hash, assert_current_call_valid_authwit};\n\n    #[aztec(storage)]\n    struct Storage {\n      reject_all: Map<AztecAddress, PublicMutable<bool>>,\n      // on_behalf_of => authwit hash => authorized\n      approved_actions: Map<AztecAddress, Map<Field, PublicMutable<bool>>>,\n    }\n\n    /**\n     * Updates the `authorized` value for `msg_sender` for `message_hash`.\n     *\n     * @param message_hash The message hash being authorized\n     * @param authorize True if the caller is authorized to perform the message hash, false otherwise\n     */\n    #[aztec(public)]\n    fn set_authorized(message_hash: Field, authorize: bool) {\n        storage.approved_actions.at(context.msg_sender()).at(message_hash).write(authorize);\n    }\n\n    /**\n     * Updates the `reject_all` value for `msg_sender`.\n     * \n     * When `reject_all` is `true` any `consume` on `msg_sender` will revert.\n     * \n     * @param reject True if all actions should be rejected, false otherwise\n     */\n    #[aztec(public)]\n    fn set_reject_all(reject: bool) {\n        storage.reject_all.at(context.msg_sender()).write(reject);\n    }\n\n    /**\n     * Consumes an `inner_hash` on behalf of `on_behalf_of` if the caller is authorized to do so.\n     * \n     * Will revert even if the caller is authorized if `reject_all` is set to true for `on_behalf_of`.\n     * This is to support \"mass-revoke\".\n     *\n     * @param on_behalf_of The address on whose behalf the action is being consumed\n     * @param inner_hash The inner_hash of the authwit\n     * @return `IS_VALID_SELECTOR` if the action was consumed, revert otherwise\n     */\n    #[aztec(public)]\n    fn consume(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n        assert_eq(false, storage.reject_all.at(on_behalf_of).read(), \"rejecting all\");\n\n        let message_hash = compute_authwit_message_hash(\n            context.msg_sender(),\n            context.chain_id(),\n            context.version(),\n            inner_hash\n        );\n\n        let authorized = storage.approved_actions.at(on_behalf_of).at(message_hash).read();\n\n        assert_eq(true, authorized, \"unauthorized\");\n        storage.approved_actions.at(on_behalf_of).at(message_hash).write(false);\n\n        IS_VALID_SELECTOR\n    }\n\n    /**\n     * Updates a public authwit using a private authwit\n     * \n     * Useful for the case where you want someone else to insert a public authwit for you.\n     * For example, if Alice wants Bob to insert an authwit in public, such that they can execute\n     * a trade, Alice can create a private authwit, and Bob can call this function with it.\n     *\n     * @param approver The address of the approver (Alice in the example)\n     * @param message_hash The message hash to authorize\n     * @param authorize True if the message hash should be authorized, false otherwise\n     */\n    #[aztec(private)]\n    fn set_authorized_private(approver: AztecAddress, message_hash: Field, authorize: bool) {\n        assert_current_call_valid_authwit(&mut context, approver);\n        AuthRegistry::at(context.this_address())._set_authorized(approver, message_hash, authorize).enqueue(&mut context);\n    }\n\n    /**\n     * Internal function to update the `authorized` value for `approver` for `messageHash`.\n     * Used along with `set_authorized_private` to update the public authwit.\n     * \n     * @param approver The address of the approver\n     * @param message_hash The message hash being authorized\n     * @param authorize True if the caller is authorized to perform the message hash, false otherwise\n     */\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _set_authorized(approver: AztecAddress, message_hash: Field, authorize: bool) {\n        storage.approved_actions.at(approver).at(message_hash).write(authorize);\n    }\n\n    /**\n     * Fetches the `reject_all` value for `on_behalf_of`.\n     * \n     * @param on_behalf_of The address to check\n     * @return True if all actions are rejected, false otherwise\n     */\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_reject_all(on_behalf_of: AztecAddress) -> bool {\n        storage.reject_all.at(on_behalf_of).read()\n    }\n\n    /**\n     * Fetches the `authorized` value for `on_behalf_of` for `message_hash`.\n     * \n     * @param on_behalf_of The address on whose behalf the action is being consumed\n     * @param message_hash The message hash to check\n     * @return True if the caller is authorized to perform the action, false otherwise\n     */\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_consumable(on_behalf_of: AztecAddress, message_hash: Field) -> bool {\n        storage.approved_actions.at(on_behalf_of).at(message_hash).read()\n    }\n\n    unconstrained fn unconstrained_is_consumable(on_behalf_of: AztecAddress, message_hash: Field) -> pub bool {\n        storage.approved_actions.at(on_behalf_of).at(message_hash).read()\n    }\n}\n"
        },
        "64": {
            "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/authwit/src/auth.nr",
            "source": "use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER, GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    CANONICAL_AUTH_REGISTRY_ADDRESS\n},\n    hash::pedersen_hash\n};\nuse dep::aztec::{prelude::Deserialize, context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties \n * (e.g. protocols or other users) to execute an action on their behalf.\n * \n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be \n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few \n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can \n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be \n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n * \n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer. \n * \n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is \n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n * \n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline \n * how this would look in private, and then in public later. \n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX). \n * `Alice` would make a `deposit` transaction, that she is executing using her account contract. \n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token` \n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to \n * convince the `Token` contract that it is allowed to do so. \n * \n * This is where the authentication witness comes in! The `Token` contract computes a `message_hash` from the \n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to \n * execute that call.\n * \n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her \n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n * \n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n * \n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts. \n * \n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *  \n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store \n * the messages that we have approved. \n * \n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `keccak256(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a colission and we return \n *      a success flag.\n * \n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be \n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the \n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n * \n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains. \n */\n\nglobal IS_VALID_SELECTOR = 0xabf64ad4; // 4 first bytes of keccak256(\"IS_VALID()\")\n\n/** \n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([context.msg_sender().to_field(), context.selector().to_field(), context.args_hash]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/** \n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n * \n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n * \n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize  \n */\npub fn assert_inner_hash_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context.static_call_private_function(\n        on_behalf_of,\n        FunctionSelector::from_signature(\"verify_private_authwit(Field)\"),\n        [inner_hash]\n    ).unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier, 0);\n}\n\n/** \n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash(\n        [(*context).msg_sender().to_field(), (*context).selector().to_field(), (*context).get_args_hash()]\n    );\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/** \n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    let result: Field = context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"consume((Field),Field)\"),\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default()\n    ).deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness \n * \n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n * \n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N]\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash = compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n * \n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n * \n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    pedersen_hash(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/** \n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n * \n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n * \n * @param on_behalf_of The address that have authorized the the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    pedersen_hash(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n * \n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(consumer: AztecAddress, chain_id: Field, version: Field, inner_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        consumer.to_field(),\n        chain_id,\n        version,\n        inner_hash\n    ],\n        GENERATOR_INDEX__AUTHWIT_OUTER\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n * \n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n * \n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_authorized(Field,bool)\"),\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n * \n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise \n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_reject_all(bool)\"),\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n"
        },
        "77": {
            "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/hash.nr",
            "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"
        },
        "78": {
            "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
            "source": "use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
        },
        "94": {
            "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
            "source": "use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
        }
    }
}